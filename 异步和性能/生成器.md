<!--
 * @Author: jiaminghui
 * @Date: 2023-01-30 15:47:15
 * @LastEditTime: 2023-01-31 19:13:45
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\异步和性能\生成器.md
 * @Description: 
-->
# 生成器的学习
ES6 生成器（generator）可以让代码变成一种顺序、看似同步的异步流程控制表达风格
## 打破完整运行
1.  JavaScript开发者在代码中几乎普遍依赖的一个假定：一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。ES6引入了一个新的函数类型，它并不符合这种运行到结束的特性。这类新的函数被称为生成器
    ```javascript
    var x = 1; 
    function foo() { 
        x++; 
        bar(); // <-- 这一行是什么作用？
        console.log( "x:", x ); 
    } 
    function bar() { 
        x++; 
    } 
    foo(); // x: 3 
    ```
    - 在这个例子中，我们确信`bar()`会在`x++`和`console.log(x)`之间运行。但是，如果`bar()`并不在那里会怎样呢？显然结果就会是2，而不是3
    - 如果`bar()`并不在那儿，在抢占式多线程语言中，`bar()`可以在`x++`和`console.log(x)`语句之间打断并运行。但JavaScript并不是抢占式的，（目前）也不是多线程的。然而，如果`foo()`自身可以通过某种形式在代码的这个位置指示暂停的话，那就仍然可以以一种合作式的方式实现这样的中断（并发）
    - 下面是实现这样的合作式并发的ES6代码
        ```javascript
        var x = 1; 
        function *foo() { 
            x++; 
            yield; // 暂停！
            console.log( "x:", x ); 
        } 
        function bar() { 
            x++; 
        } 
        ```
    - 现在，我们要如何运行前面的代码片段，使得`bar()`在`*foo()`内部的yield处执行呢
        ```javascript
        // 构造一个迭代器it来控制这个生成器
        var it = foo(); 
        // 这里启动foo()！
        it.next(); 
        x; // 2 
        bar(); 
        x; // 3 
        it.next(); // x: 3 
        ```
        - `it = foo()`运算并没有执行生成器`*foo()`，而只是构造了一个迭代器（iterator），这个迭代器会控制它的执行
        - 第一个`it.next()`启动了生成器`*foo()`，并运行了`*foo()`第一行的`x++`
        - `*foo()`在yield语句处暂停，在这一点上第一个`it.next()`调用结束。此时`*foo()`仍在运行并且是活跃的，但处于暂停状态
        - 我们查看x的值，此时为2
        - 我们调用`bar()`，它通过`x++`再次递增x
        - 我们再次查看x的值，此时为3
        - 最后的`it.next()`调用从暂停处恢复了生成器`*foo()`的执行，并运行`console.log(..)`语句，这条语句使用当前x的值3
        - 显然，`foo()`启动了，但是没有完整运行，它在yield处暂停了。后面恢复了foo()并让它运行到结束，但这不是必需的
    - 因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成
### 输入和输出
1.  生成器函数是一个特殊的函数，但是，它仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。比如，它仍然可以接受参数（即输入），也能够返回值（即输出）
    ```javascript
    function *foo(x,y) { 
        return x * y; 
    } 
    var it = foo( 6, 7 ); 
    var res = it.next(); 
    res.value; // 42
    ```
    - 我们向`*foo(..)`传入实参6和7分别作为参数x和y。`*foo(..)`向调用代码返回42
    - 现在我们可以看到生成器和普通函数在调用上的一个区别。生成器`*foo(..)`并没有像普通函数一样实际运行
    - 事实上，我们只是创建了一个迭代器对象，把它赋给了一个变量it，用于控制生成器`*foo(..)`。然后调用`it.next()`，指示生成器`*foo(..)`从当前位置开始继续运行，停在下一个yield处或者直到生成器结束
    - 这个next(..)调用的结果是一个对象，它有一个value属性，持有从`*foo(..)`返回的值（如果有的话）。换句话说，yield会导致生成器在执行过程中发送出一个值，这有点类似于中间的return
2.  除了能够接受参数并提供返回值之外，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过yield和next(..)实现
    ```javascript
    function *foo(x) { 
        var y = x * (yield); 
        return y; 
    } 
    var it = foo( 6 ); 
    // 启动foo(..) 
    it.next(); 
    var res = it.next( 7 ); 
    res.value; // 42
    ```
    - 首先，传入6作为参数x。然后调用`it.next()`，这会启动`*foo(..)`
    - 在`*foo(..)`内部，开始执行语句`var y = x ..`，但随后就遇到了一个yield表达式。它就会在这一点上暂停`*foo(..)`（在赋值语句中间！），并在本质上要求调用代码为yield表达式提供一个结果值
    - 接下来，调用`it.next( 7 )`，这一句把值7传回作为被暂停的yield表达式的结果。所以，这时赋值语句实际上就是`var y = 6 * 7`。现在，`return y`返回值42作为调用`it.next( 7 )`的结果
    - 注意：yield和`next(..)`调用有一个不匹配。一般来说，需要的`next(..)`调用要比yield语句多一个，前面的代码片段有一个yield和两个`next(..)`调用。因为第一个`next(..)`总是启动一个生成器，并运行到第一个yield处。不过，是第二个`next(..)`调用完成第一个被暂停的yield表达式，第三个`next(..)`调用完成第二个yield，以此类推
3.  只考虑生成器代码
    ```javascript
    var y = x * (yield); 
    return y; 
    ```
    - 第一个yield基本上是提出了一个问题：“这里我应该插入什么值？”
    - 谁来回答这个问题呢？第一个`next()`已经运行，使得生成器启动并运行到此处，所以显然它无法回答这个问题。因此必须由第二个`next(..)`调用回答第一个yield提出的这个问题，这里的不匹配就是第二个对第一个
    - 不从生成器的视角看这个问题，而是从迭代器的角度。消息是双向传递的——`yield..`作为一个表达式可以发出消息响应`next(..)`调用，`next(..)`也可以向暂停的yield表达式发送值
        ```javascript
        function *foo(x) { 
            var y = x * (yield "Hello"); // <-- yield一个值！
            return y; 
        } 
        var it = foo( 6 ); 
        var res = it.next(); // 第一个next()，并不传入任何东西
        res.value; // "Hello" 
        res = it.next( 7 ); // 向等待的yield传入7
        res.value; // 42 
        ```
        - `yield ..`和`next(..)`这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统
        - 第一个`next()`调用（没有参数的）基本上就是在提出一个问题：“生成器`*foo(..)`要给我的下一个值是什么”。谁来回答这个问题呢？第一个`yield "hello"`表达式
        - 但是，与yield语句的数量相比，还是多出了一个额外的`next()`。所以，最后一个`it.next(7)`调用再次提出了这样的问题：生成器将要产生的下一个值是什么。但是，再没有yield语句来回答这个问题了，那么return语句回答这个问题
        - 如果你的生成器中没有return的话——在生成器中和在普通函数中一样，return当然不是必需的——总有一个假定的/隐式的return;（也就是`return undefined;`），它会在默认情况下回答最后的`it.next(7)`调用提出的问题
### 多个迭代器
1.  从语法使用的方面来看，通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。但有一个细微之处很容易忽略：每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互
    ```javascript
    function *foo() { 
        var x = yield 2; 
        z++; 
        var y = yield (x * z); 
        console.log( x, y, z ); 
    } 
    var z = 1; 
    var it1 = foo(); 
    var it2 = foo(); 
    var val1 = it1.next().value; // 2 <-- yield 2 
    var val2 = it2.next().value; // 2 <-- yield 2 
    val1 = it1.next( val2 * 10 ).value; // 40 <-- x:20, z:2 
    val2 = it2.next( val1 * 5 ).value; // 600 <-- x:200, z:3 
    it1.next( val2 / 2 ); // y:300 
    // 20 300 3 
    it2.next( val1 / 4 ); // y:10 
    // 200 10 3
    ```
2.  交替执行
    ```javascript
    var a = 1; 
    var b = 2; 
    function foo() { 
        a++; 
        b = b * a; 
        a = b + 3; 
    } 
    function bar() { 
        b--; 
        a = 8 + b; 
        b = a * 2; 
    } 
    ```
    - 如果是普通的JavaScript函数的话，显然，要么是`foo()`首先运行完毕，要么是`bar()`首先运行完毕，但`foo()`和`bar()`的语句不能交替执行。所以，前面的程序只有两种可能的输出
    - 但是，使用生成器的话，交替执行（甚至在语句当中！）显然是可能的
        ```javascript
        var a = 1; 
        var b = 2; 
        function *foo() { 
            a++; 
            yield; 
            b = b * a; 
            a = (yield b) + 3; 
        } 
        function *bar() { 
            b--; 
            yield; 
            a = (yield 8) + b; 
            b = a * (yield 2); 
        } 
        ```
        - 根据迭代器控制的`*foo()`和`*bar()`调用的相对顺序不同，前面的程序可能会产生多种不同的结果。换句话说，通过两个生成器在共享的相同变量上的迭代交替执行，我们实际上可以（以某种模拟的方式）印证第1章讨论的理论上的多线程竞态条件环境
    - 首先，来构建一个名为`step(..)`的辅助函数，用于控制迭代器
        ```javascript
        function step(gen) { 
            var it = gen(); 
            var last; 
            return function() { 
                // 不管yield出来的是什么，下一次都把它原样传回去！
                last = it.next( last ).value; 
            }; 
        } 
        ```
        - `step(..)`初始化了一个生成器来创建迭代器it，然后返回一个函数，这个函数被调用的时候会将迭代器向前迭代一步。另外，前面的yield发出的值会在下一步发送回去。于是，`yield 8`就是8，而`yield b`就是b（yield发出时的值）
    - 现在，我们来试验一下交替运行`*foo()`和`*bar()`代码块的效果
        - 确保`*foo()`在`*bar()`之前完全结束
            ```javascript
            // 确保重新设置a和b 
            a = 1; 
            b = 2; 
            var s1 = step( foo ); 
            var s2 = step( bar ); 
            // 首次运行*foo()
            s1(); 
            s1(); 
            s1(); 
            // 现在运行*bar() 
            s2(); 
            s2(); 
            s2(); 
            s2(); 
            console.log( a, b ); // 11 22
            ```
        - 现在交替执行顺序，看看a和b的值是如何改变的
            ```javascript
            // 确保重新设置a和b
            a = 1; 
            b = 2; 
            var s1 = step( foo ); 
            var s2 = step( bar ); 
            s2(); // b--; 
            s2(); // yield 8  
            s1(); // a++; 
            s2(); // a = 8 + b; 
            // yield 2 
            s1(); // b = b * a; 
            // yield b 
            s1(); // a = b + 3; 
            s2(); // b = a * 2; 
            console.log( a, b ); // 12 18 
            ```
            - 为什么最后在执行`s1();s2();`之前a和b均为9，但是再次执行`s1();s2();`两个表达式的顺序并不会影响a和b的值，是因为，在迭代器让生成器继续运行之前，表达式已经将上一次执行结果a和b均为9的值带入到表达式，所以即使先执行`s1();`后对a的值进行了更新，但是并不会影响`s2();`中`b = a * 2`中的a，a的值还是9，而不是更新后的12

## 生成器产生值
### 生产者与迭代器
1.  假定你要产生一系列值，其中每个值都与前面一个有特定的关系。要实现这一点，需要一个有状态的生产者能够记住其生成的最后一个值
    - 可以实现一个直接使用函数闭包的版本
        ```javascript
        var gimmeSomething = (function(){ 
            var nextVal; 
            return function(){ 
                if (nextVal === undefined) { 
                    nextVal = 1; 
                } 
                else { 
                    nextVal = (3 * nextVal) +6; 
                } 
                return nextVal; 
            }; 
        })(); 
        gimmeSomething(); // 1 
        gimmeSomething(); // 9 
        gimmeSomething(); // 33 
        gimmeSomething(); // 105 
        ```
2.  实际上，这个任务是一个非常通用的设计模式，通常通过迭代器来解决。迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值。JavaScript迭代器的接口，与多数语言类似，就是每次想要从生产者得到下一个值的时候调用`next()`
    - 可以为我们的数字序列生成器实现标准的迭代器接口
        ```javascript
        var something = (function(){ 
            var nextVal; 
            return { 
                // for..of循环需要
                [Symbol.iterator]: function(){ return this; }, 
                // 标准迭代器接口方法
                next: function(){ 
                    if (nextVal === undefined) { 
                        nextVal = 1; 
                    } 
                    else { 
                        nextVal = (3 * nextVal) + 6; 
                    } 
                    return { done:false, value:nextVal }; 
                } 
            }; 
        })(); 
        something.next().value; // 1 
        something.next().value; // 9 
        something.next().value; // 33 
        something.next().value; // 105 
        ```
        - `next()`调用返回一个对象。这个对象有两个属性：done是一个boolean值，标识迭代器的完成状态；value中放置迭代值
    - ES6还新增了一个`for..of`循环，这意味着可以通过原生循环语法自动迭代标准迭代器
        ```javascript
        for (var v of something) { 
            console.log( v ); 
            // 不要死循环！
            if (v > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969
        ```
        - 因为我们的迭代器something总是返回`done:false`，因此这个`for..of`循环将永远运行下去。但是也有一些情况下，迭代器会在有限的值集合上运行，并最终返回`done:true`
        - `for..of`循环在每次迭代中自动调用`next()`，它不会向`next()`传入任何值，并且会在接收到`done:true`之后自动停止
    - 当然，也可以手工在迭代器上循环，调用`next()`并检查`done:true`条件来确定何时停止循环
        ```javascript
        for ( 
            var ret; 
            (ret = something.next()) && !ret.done; 
        ) { 
            console.log( ret.value ); 
            // 不要死循环！
            if (ret.value > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969 
        ```
        - 这种手工for方法当然要比ES6的`for..of`循环语法丑陋，但其优点是，这样就可以在需要时向`next()`传递值
3.  除了构造自己的迭代器，许多JavaScript的内建数据结构（从ES6开始），比如array，也有默认的迭代器
    ```javascript
    var a = [1,3,5,7,9]; 
    for (var v of a) { 
        console.log( v ); 
    } 
    // 1 3 5 7 9 
    ```
    - 不过一般的object是故意不像array一样有默认的迭代器。如果你只是想要迭代一个对象的所有属性的话（不需要保证特定的顺序），可以通过`Object.keys(..)`返回一个array，类似于`for (var k of Object.keys(obj)) { ..`这样使用。这样在一个对象的键值上使用`for..of`循环与`for..in`循环类似。`Object.keys(..)`并不包含来自于`[[Prototype]]`链上的属性，而`for..in`则包含
### iterable
1.  前面例子中的something对象叫作迭代器，因为它的接口中有一个`next()`方法。而与其紧密相关的一个术语是iterable（可迭代），即指一个包含可以在其值上迭代的迭代器的对象
2.  从ES6开始，从一个iterable中提取迭代器的方法是：iterable必须支持一个函数，其名称是专门的ES6符号值`Symbol.iterator`。调用这个函数时，它会返回一个迭代器。通常每次调用会返回一个全新的迭代器，虽然这一点并不是必须的
    - 前面代码片段中的a就是一个iterable。`for..of`循环自动调用它的`Symbol.iterator`函数来构建一个迭代器。我们当然也可以手工调用这个函数，然后使用它返回的迭代器
        ```javascript
        var a = [1,3,5,7,9]; 
        var it = a[Symbol.iterator](); 
        it.next().value; // 1 
        it.next().value; // 3 
        it.next().value; // 5 
        .. 
        ```
    - 前面的代码中列出了定义的something，你可能已经注意到了这一行`[Symbol.iterator]: function(){ return this; } `
        - 将something的值（迭代器something的接口）也构建成为一个iterable。现在它既是iterable，也是迭代器。然后我们把something传给`for..of`循环
            ```javascript
            for (var v of something) { 
                .. 
            } 
            ```
            - `for..of`循环期望something是iterable，于是它寻找并调用它的`Symbol.iterator`函数。我们将这个函数定义为就是简单的`return this`，也就是把自身返回，而`for..of`循环并不知情
### 生成器迭代器
1.  可以把生成器看作一个值的生产者，我们通过迭代器接口的`next()`调用一次提取出一个值
    - 所以，严格说来，生成器本身并不是iterable，尽管非常类似——当你执行一个生成器，就得到了一个迭代器
        ```javascript
        function *foo(){ .. } 
        var it = foo();
        ```
    - 可以通过生成器实现前面的这个something无限数字序列生产者，类似这样
        ```javascript
        function *something() { 
            var nextVal; 
            while (true) { 
                if (nextVal === undefined) { 
                    nextVal = 1; 
                } 
                else { 
                    nextVal = (3 * nextVal) + 6; 
                } 
                yield nextVal; 
            } 
        } 
        ```
        - 因为生成器会在每个yield处暂停，函数`*something()`的状态（作用域）会被保持，即意味着不需要闭包在调用之间保持变量状态
    - 现在，可以通过`for..of`循环使用我们雕琢过的新的`*something()`生成器。你可以看到，其工作方式基本是相同的
        ```javascript
        for (var v of something()) { 
            console.log( v ); 
            // 不要死循环！
            if (v > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969 
        ```
        - 但是，不要忽略了这段`for (var v of something()) ..`！我们并不是像前面的例子那样把something当作一个值来引用，而是调用了`*something()`生成器以得到它的迭代器供`for..of`循环使用。而之前的代码是将something当作一个iterable
        - `something()`·`调用产生一个迭代器，但`for..of`循环需要的是一个iterable，对吧？是的。生成器的迭代器也有一个`Symbol.iterator`函数，基本上这个函数做的就是`return this`，和我们前面定义的iterable`something`一样。换句话说，生成器的迭代器也是一个iterable
2.  停止生成器
    - 在前面的例子中，看起来似乎`*something()`生成器的迭代器实例在循环中的break调用之后就永远留在了挂起状态。其实有一个隐藏的特性会帮助你管理此事。`for..of`循环的“异常结束”（也就是“提前终止”），通常由break、return或者未捕获异常引起，会向生成器的迭代器发送一个信号使其终止
    - 严格地说，在循环正常结束之后，`for..of`循环也会向迭代器发送这个信号
    - 尽管`for..of`循环会自动发送这个信号，但你可能会希望向一个迭代器手工发送这个信号。可以通过调用`return(..)`实现这一点。如果在生成器内有`try..finally`语句，它将总是运行，即使生成器已经外部结束。如果需要清理资源的话（数据库连接等），这一点非常有用
        ```javascript
        function *something() { 
            try { 
                var nextVal; 
                while (true) { 
                    if (nextVal === undefined) { 
                        nextVal = 1; 
                    } 
                    else { 
                        nextVal = (3 * nextVal) + 6; 
                    } 
                    yield nextVal; 
                } 
            } 
            // 清理子句
            finally { 
                console.log( "cleaning up!" ); 
            } 
        } 
        ```
        - 之前的例子中，`for..of`循环内的break会触发finally语句。但是，也可以在外部通过`return(..)`手工终止生成器的迭代器实例
            ```javascript
            var it = something(); 
            for (var v of it) { 
                console.log( v ); 
                // 不要死循环！
                if (v > 500) { 
                    console.log( 
                        // 完成生成器的迭代器
                        it.return( "Hello World" ).value 
                    ); 
                    // 这里不需要break 
                } 
            } 
            // 1 9 33 105 321 969
            // 清理！
            // Hello World 
            ```
            - 调用`it.return(..)`之后，它会立即终止生成器，这当然会运行finally语句。另外，它还会把返回的value设置为传入`return(..)`的内容，这也就是`"Hello World"`被传出去的过程。现在我们也不需要包含break语句了，因为生成器的迭代器已经被设置为`done:true`，所以`for..of`循环会在下一个迭代终止

## 异步迭代生成器
1.  生成器与异步编码模式及解决回调问题等，有什么关系
    - 回调方法
        ```javascript
        function foo(x,y,cb) { 
            ajax( 
                "http://some.url.1/?x=" + x + "&y=" + y, 
                cb 
            ); 
        } 
        foo( 11, 31, function(err,text) { 
            if (err) { 
                console.error( err ); 
            } 
            else { 
                console.log( text ); 
            } 
        } );
        ```
    - 生成器来表达同样的任务流程控制
        ```javascript
        function foo(x,y) { 
            ajax( 
                "http://some.url.1/?x=" + x + "&y=" + y, 
                function(err,data){ 
                    if (err) { 
                        // 向*main()抛出一个错误
                        it.throw( err ); 
                    } 
                    else { 
                        // 用收到的data恢复*main() 
                        it.next( data ); 
                    } 
                } 
            ); 
        } 
        function *main() { 
            try { 
                var text = yield foo( 11, 31 ); 
                console.log( text ); 
            } 
            catch (err) { 
                console.error( err ); 
            } 
        } 
        var it = main(); 
        // 这里启动！
        it.next(); 
        ```
        - 首先，让我们查看一下最重要的这段代码`var text = yield foo( 11, 31 );console.log( text );`。我们调用了一个普通函数`foo(..)`，而且显然能够从Ajax调用中得到text，即使它是异步的。而代码`var data = ajax( "..url 1.." );console.log( data );`不能工作！区别就在于生成器中使用的yield
        - 正是这一点使得我们看似阻塞同步的代码，实际上并不会阻塞整个程序，它只是暂停或阻塞了生成器本身的代码
        - 在`yield foo(11,31)`中，首先调用`foo(11,31)`，它没有返回值（即返回undefined），所以我们发出了一个调用来请求数据，但实际上之后做的是`yield undefined`。这段代码当前并不依赖yield出来的值来做任何事情
        - 这里并不是在消息传递的意义上使用yield，而只是将其用于流程控制实现暂停/阻塞。实际上，它还是会有消息传递，但只是生成器恢复运行之后的单向消息传递`it.next(data);`
2.  同步错误处理
    ```javascript
    try { 
        var text = yield foo( 11, 31 ); 
        console.log( text ); 
    } 
    catch (err) { 
        console.error( err ); 
    } 
    ```
    - `try..catch`本质上是无法捕获异步错误，我们已经看到yield是如何让赋值语句暂停来等待`foo(..)`完成，使得响应完成后可以被赋给text。精彩的部分在于yield暂停也使得生成器能够捕获错误。通过这段前面列出的代码把错误抛出到生成器中
        ```javascript
        if (err) { 
            // 向*main()抛出一个错误
            it.throw( err ); 
        } 
        ```
    
    - 生成器yield暂停的特性意味着我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误
    - 我们可以把错误抛入生成器中，不过如果是从生成器向外抛出错误呢
        ```javascript
        function *main() { 
            var x = yield "Hello World"; 
            yield x.toLowerCase(); // 引发一个异常！
        } 
        var it = main(); 
        it.next().value; // Hello World 
        try { 
            it.next( 42 ); 
        } 
        catch (err) { 
            console.error( err ); // TypeError 
        } 
        ```
        - 当然，也可以通过`throw ..`手工抛出一个错误，而不是通过触发异常
    - 甚至可以捕获通过`throw(..)`抛入生成器的同一个错误，基本上也就是给生成器一个处理它的机会；如果没有处理的话，迭代器代码就必须处理：
        ```javascript
        function *main() { 
            var x = yield "Hello World"; 
            // 永远不会到达这里
            console.log( x ); 
        } 
        var it = main(); 
        it.next(); 
        try { 
            // *main()会处理这个错误吗？看看吧！
            it.throw( "Oops" ); 
        } 
        catch (err) { 
            // 不行，没有处理！
            console.error( err ); // Oops 
        }
        ```

## 生成器+Promise
1.  运行Ajax例子中基于Promise的实现方法
    ```javascript
    function foo(x,y) { 
        return request( 
            "http://some.url.1/?x=" + x + "&y=" + y 
        ); 
    } 
    foo( 11, 31 ) 
    .then( 
        function(text){ 
            console.log( text ); 
        }, 
        function(err){ 
            console.error( err ); 
        } 
    ); 
    ```
    - 在前面的运行Ajax例子的生成器代码中，`foo(..)`没有返回值（undefined），并且我们的迭代器控制代码并不关心yield出来的值
    - 而这里支持Promise的`foo(..)`在发出Ajax调用之后返回了一个promise。这暗示我们可以通过`foo(..)`构造一个promise，然后通过生成器把它yield出来，然后迭代器控制代码就可以接收到这个promise了
2.  获得Promise和生成器最大效用的最自然的方法就是yield出来一个Promise，然后通过这个Promise来控制生成器的迭代器。侦听这个promise的决议（完成或拒绝），然后要么使用完成消息恢复生成器运行，要么向生成器抛出一个带有拒绝原因的错误
    - 首先，把支持Promise的`foo(..)`和生成器`*main()`放在一起
        ```javascript
        function foo(x,y) { 
            return request( 
                "http://some.url.1/?x=" + x + "&y=" + y 
            ); 
        } 
        function *main() { 
            try { 
                var text = yield foo( 11, 31 ); 
                console.log( text ); 
            } 
            catch (err) { 
                console.error( err ); 
            } 
        } 
        ```
        - 这次重构代码中最有力的发现是，`*main()`之中的代码完全不需要改变！在生成器内部，不管什么值yield出来，都只是一个透明的实现细节，所以我们甚至没有意识到其发生，也不需要关心
    - 但现在如何运行`*main()`呢？还有一些实现细节需要补充，来实现接收和连接yield出来的promise，使它能够在决议之后恢复生成器
        ```javascript
        var it = main(); 
        var p = it.next().value; 
        // 等待promise p决议
        p.then( 
            function(text){ 
                it.next( text ); 
            }, 
            function(err){ 
                it.throw( err ); 
            } 
        ); 
        ```

### 支持Promise的Generator Runner
1.  如果有某个工具为我实现重复（即循环）迭代控制，每次会生成一个Promise，等其决议后再继续就好了。这是如此重要的一个模式，你绝对不希望搞错（或精疲力竭地一次又一次重复实现），所以最好是使用专门设计用来以我们前面展示的方式运行Promise-yielding生成器的工具
    - 为了学习和展示的目的，我们还是自己定义一个独立工具，叫作`run(..)`：有几个Promise抽象库提供了这样的工具，包括我的asynquence库及其`runner(..)`
        ```javascript
        // 在此感谢Benjamin Gruenbaum （@benjamingr on GitHub）的巨大改进！
        function run(gen) { 
            var args = [].slice.call( arguments, 1), it; 
            // 在当前上下文中初始化生成器
            it = gen.apply( this, args ); 
            // 返回一个promise用于生成器完成
            return Promise.resolve() 
            .then( function handleNext(value){ 
                // 对下一个yield出的值运行
                var next = it.next( value ); 
                return (function handleResult(next){ 
                    // 生成器运行完毕了吗？
                    if (next.done) { 
                        return next.value; 
                    } 
                    // 否则继续运行
                    else { 
                        return Promise.resolve( next.value ) 
                        .then( 
                            // 成功就恢复异步循环，把决议的值发回生成器
                            handleNext, 
                            // 如果value是被拒绝的 promise，
                            // 就把错误传回生成器进行出错处理
                            function handleErr(err) { 
                                return Promise.resolve( 
                                    it.throw( err ) 
                                ) 
                                .then( handleResult ); 
                            } 
                        ); 
                    } 
                })(next); 
            } ); 
        } 
        ```
        - 你可能并不愿意编写这么复杂的工具，并且也会特别不希望为每个使用的生成器都重复这段代码。所以，一个工具或库中的辅助函数绝对是必要的。尽管如此，我还是建议你花费几分钟时间学习这段代码，以更好地理解生成器+Promise协同运作模式
    - 如何在运行Ajax的例子中使用`run(..)`和`*main()`呢
        ```javascript
        function *main() { 
            // .. 
        } 
        run( main ); 
        ```
        - 就是这样！这种运行`run(..)`的方式，它会自动异步运行你传给它的生成器，直到结束
        - 我们定义的`run(..)`返回一个promise，一旦生成器完成，这个promise就会决议，或收到一个生成器没有处理的未捕获异常
2.  前面的模式——生成器yield出Promise，然后其控制生成器的迭代器来执行它，直到结束——是非常强大有用的一种方法。如果我们能够无需库工具辅助函数（即`run(..)`）就能够实现就好了
    - 对于后ES6、ES7的时间框架，在这一方面增加语法支持的提案已经有了一些初期但很强势的支持。显然，现在确定细节还太早，但其形式很可能会类似如下
        ```javascript
        function foo(x,y) { 
            return request( 
                "http://some.url.1/?x=" + x + "&y=" + y 
            ); 
        } 
        async function main() { 
            try { 
                var text = await foo( 11, 31 ); 
                console.log( text ); 
            } 
            catch (err) { 
                console.error( err ); 
            } 
        } 
        main(); 
        ```
        - 可以看到，这里没有通过`run(..)`调用（意味着不需要库工具！）来触发和驱动`main()`，它只是被当作一个普通函数调用。另外，`main()`也不再被声明为生成器函数了，它现在是一类新的函数：async函数。最后，我们不再yield出Promise，而是用await等待它决议
        - 如果你await了一个Promise，async函数就会自动获知要做什么，它会暂停这个函数（就像生成器一样），直到Promise决议。我们并没有在这段代码中展示这一点，但是调用一个像`main()`这样的async函数会自动返回一个promise。在函数完全结束之后，这个promise会决议

### 生成器中的Promise并发
1.  到目前为止，我们已经展示的都是Promise+生成器下的单步异步流程。但是，现实世界中的代码常常会有多个异步步骤
    - 想象这样一个场景：你需要从两个不同的来源获取数据，然后把响应组合在一起以形成第三个请求，最终把最后一条响应打印出来，你的第一直觉可能类似如下
        ```javascript
        function *foo() { 
            var r1 = yield request( "http://some.url.1" ); 
            var r2 = yield request( "http://some.url.2" ); 
            var r3 = yield request( 
                "http://some.url.3/?v=" + r1 + "," + r2 
            ); 
            console.log( r3 ); 
        } 
        // 使用前面定义的工具run(..) 
        run( foo ); 
        ```
        - 这段代码可以工作，但是针对我们特定的场景而言，它并不是最优的。原因是因为请求r1和r2能够——出于性能考虑也应该——并发执行，但是在这段代码中，它们是依次执行的；直到请求URL`"http://some.url.1"`完成后才会通过Ajax获取URL`"http://some.url.2"`。这两个请求是相互独立的，所以性能更高的方案应该是让它们同时运行
    - 但是，到底如何通过生成器和yield实现这一点呢？我们知道yield只是代码中一个单独的暂停点，并不可能同时在两个点上暂停。最自然有效的答案就是让异步流程基于Promise，特别是基于它们以时间无关的方式管理状态的能力
        ```javascript
        function *foo() { 
            // 让两个请求"并行"
            var p1 = request( "http://some.url.1" ); 
            var p2 = request( "http://some.url.2" ); 
            // 等待两个promise都决议
            var r1 = yield p1; 
            var r2 = yield p2; 
            var r3 = yield request( 
                "http://some.url.3/?v=" + r1 + "," + r2 
            ); 
            console.log( r3 ); 
        } 
        // 使用前面定义的工具run(..)
        run( foo ); 
        ```
        - 为什么这和前面的代码片段不同呢？观察一下yield的位置。p1和p2是并发执行（即“并行”）的用于Ajax请求的promise。哪一个先完成都无所谓，因为promise会按照需要在决议状态保持任意长时间
        - 然后我们使用接下来的两个yield语句等待并取得promise的决议（分别写入r1和r2）。如果p1先决议，那么`yield p1`就会先恢复执行，然后等待`yield p2`恢复。如果p2先决议，它就会耐心保持其决议值等待请求，但是`yield p1`将会先等待，直到p1决议。不管哪种情况，p1和p2都会并发执行，无论完成顺序如何，两者都要全部完成，然后才会发出`r3 = yield request..Ajax`请求
        - 这种流程控制模型如果听起来有点熟悉的话，是因为这基本上和`Promise.all([ .. ])`工具实现的gate模式相同
            ```javascript
            function *foo() { 
                // 让两个请求"并行"，并等待两个promise都决议
                var results = yield Promise.all( [ 
                    request( "http://some.url.1" ), 
                    request( "http://some.url.2" ) 
                ] ); 
                var r1 = results[0]; 
                var r2 = results[1]; 
                var r3 = yield request( 
                    "http://some.url.3/?v=" + r1 + "," + r2 
                ); 
                console.log( r3 ); 
            } 
            // 使用前面定义的工具run(..) 
            run( foo ); 
            ```
        - 换句话说，Promise所有的并发能力在生成器+Promise方法中都可以使用
2.  隐藏的Promise
    - 作为一个风格方面的提醒：要注意你的生成器内部包含了多少Promise逻辑。我们介绍的使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码，将异步的细节尽可能隐藏起来。比如，这可能是一个更简洁的方案
        ```javascript
        // 注：普通函数，不是生成器
        function bar(url1,url2) { 
            return Promise.all( [ 
                request( url1 ), 
                request( url2 ) 
            ] ); 
        } 
        function *foo() { 
            // 隐藏bar(..)内部基于Promise的并发细节
            var results = yield bar( 
                "http://some.url.1", 
                "http://some.url.2" 
            ); 
            var r1 = results[0]; 
            var r2 = results[1]; 
            var r3 = yield request( 
                "http://some.url.3/?v=" + r1 + "," + r2 
            ); 
            console.log( r3 ); 
        } 
        // 使用前面定义的工具run(..)
        run( foo ); 
        ```
        - 在`*foo()`内部，我们所做的一切就是要求`bar(..)`给我们一些results，并通过yield来等待结果，这样更简洁也更清晰。我们不需要关心在底层是用`Promise.all([ .. ])`Promise组合来实现这一切
    - 如果想要实现一系列高级流程控制的话，那么非常有用的做法是：把你的Promise逻辑隐藏在一个只从生成器代码中调用的函数内部
        ```javascript
        function bar() { 
            Promise.all( [ 
                baz( .. ) 
                .then( .. ), 
                Promise.race( [ .. ] ) 
            ] ) 
            .then( .. ) 
        } 
        ```

## 生成器委托
1.  在前面一节中，我们展示了从生成器内部调用常规函数，以及这如何对于把实现细节（就像异步Promise流）抽象出去还是一种有用的技术。但是，用普通函数实现这个任务的主要缺点是它必须遵守普通函数的规则，也就意味着它不能像生成器一样用yield暂停自己。
    - 可能出现的情况是，你可能会从一个生成器调用另一个生成器，使用辅助函数`run(..)`
        ```javascript
        function *foo() { 
            var r2 = yield request( "http://some.url.2" ); 
            var r3 = yield request( "http://some.url.3/?v=" + r2 ); 
            return r3; 
        } 
        function *bar() { 
            var r1 = yield request( "http://some.url.1" ); 
            // 通过 run(..) "委托"给*foo()
            var r3 = yield run( foo ); 
            console.log( r3 ); 
        } 
        run( bar ); 
        ```
        - 我们再次通过`run(..)`工具从`*bar()`内部运行`*foo()`
        - 我们前面定义的`run(..)`返回一个promise，这个promise在生成器运行结束时（或出错退出时）决议。因此，如果从一个`run(..)`调用中yield出来一个promise到另一个`run(..)`实例中，它会自动暂停`*bar()`，直到`*foo()`结束
    - 但其实还有一个更好的方法可以实现从`*bar()`调用`*foo()`，称为yield委托。yield委托的具体语法是：`yield * __`（注意多出来的*），先来看一个简单点的场景
        ```javascript
        function *foo() { 
            console.log( "*foo() starting" ); 
            yield 3; 
            yield 4; 
            console.log( "*foo() finished" ); 
        } 
        function *bar() { 
            yield 1; 
            yield 2; 
            yield *foo(); // yield委托！
            yield 5; 
        } 
        var it = bar(); 
        it.next().value; // 1 
        it.next().value; // 2 
        it.next().value; // *foo()启动
        // 3 
        it.next().value; // 4 
        it.next().value; // *foo()完成
        // 5 
        ```
    - 这里的`yield *foo()`委托是如何工作的呢
        - 首先，和我们以前看到的完全一样，调用`foo()`创建一个迭代器
        - 然后`yield *`把迭代器实例控制（当前`*bar()`生成器的）委托给`*foo()`迭代器
        - 所以，前面两个`it.next()`调用控制的是`*bar()`。但当我们发出第三个`it.next()`调用时，`*foo()`现在启动了，我们现在控制的是`*foo()`而不是`*bar()`。这也是为什么这被称为委托：`*bar()`把自己的迭代控制委托给了`*foo()`。一旦it迭代器控制消耗了整个`*foo()`迭代器，it就会自动转回控制`*bar()`
    - 现在回到前面使用三个顺序Ajax请求的例子
        ```javascript
        function *foo() { 
            var r2 = yield request( "http://some.url.2" ); 
            var r3 = yield request( "http://some.url.3/?v=" + r2 ); 
            return r3; 
        } 
        function *bar() { 
            var r1 = yield request( "http://some.url.1" ); 
            // 通过 yeild* "委托"给*foo()
            var r3 = yield *foo(); 
            console.log( r3 ); 
        } 
        run( bar ); 
        ```
        - 这段代码和前面版本的唯一区别就在于使用了`yield *foo()`，而不是前面的`yield run(foo)`
        - 你可以yield委托到任意iterable，`yield *[1,2,3]`会消耗数组值`[1,2,3]`的默认迭代器

### 为什么用委托
1.  yield委托的主要目的是代码组织，以达到与普通函数调用的对称
    - 想像一下有两个模块分别提供了方法`foo()`和`bar()`，其中`bar()`调用了`foo()`。一般来说，把两者分开实现的原因是该程序的适当的代码组织要求它们位于不同的函数中。比如，可能有些情况下是单独调用`foo()`，另外一些地方则由`bar()`调用`foo()`
    - `yield *`是一个语法上的缩写，用于代替手工在`*foo()`的步骤上迭代，而迭代是在`*bar()`内部。如果`*foo()`内的步骤是异步的话，这样的手工方法将会特别复杂，这也是你可能需要使用`run(..)`工具来做某些事情的原因。就像我们已经展示的，`yield *foo()`消除了对`run(..)`工具的需要（就像`run(foo)`）
### 消息委托
1.  这个yield委托是如何不只用于迭代器控制工作，也用于双向消息传递工作的呢。认真跟踪下面的通过yield委托实现的消息流出入
    ```javascript
    function *foo() { 
        console.log( "inside *foo():", yield "B" ); 
        console.log( "inside *foo():", yield "C" ); 
        return "D"; 
    } 
    function *bar() { 
        console.log( "inside *bar():", yield "A" ); 
        // yield委托！
        console.log( "inside *bar():", yield *foo() ); 
        console.log( "inside *bar():", yield "E" ); 
        return "F"; 
    } 
    var it = bar(); 
    console.log( "outside:", it.next().value ); 
    // outside: A 
    console.log( "outside:", it.next( 1 ).value ); 
    // inside *bar(): 1 
    // outside: B 
    console.log( "outside:", it.next( 2 ).value ); 
    // inside *foo(): 2 
    // outside: C 
    console.log( "outside:", it.next( 3 ).value ); 
    // inside *foo(): 3 
    // inside *bar(): D 
    // outside: E 
    console.log( "outside:", it.next( 4 ).value ); 
    // inside *bar(): 4 
    // outside: F 
    ```
    - 要特别注意`it.next(3)`调用之后的执行步骤
    - 值3（通过`*bar()`内部的yield委托）传入等待的`*foo()`内部的`yield "C"`表达式
    - 然后`*foo()`调用`return "D"`，但是这个值并没有一直返回到外部的`it.next(3)`调用
    - 取而代之的是，值"D"作为`*bar()`内部等待的`yield*foo()`表达式的结果发出——这个yield委托本质上在所有的`*foo()`完成之前是暂停的。所以"D"成为`*bar()`内部的最后结果，并被打印出来
    - `yield "E"`在`*bar()`内部调用，值"E"作为`it.next(3)`调用的结果被yield发出
2.  实际上，yield委托甚至并不要求必须转到另一个生成器，它可以转到一个非生成器的一般iterable。比如
    ```javascript
    function *bar() { 
        console.log( "inside *bar():", yield "A" ); 
        // yield委托给非生成器！
        console.log( "inside *bar():", yield *[ "B", "C", "D" ] ); 
        console.log( "inside *bar():", yield "E" ); 
        return "F"; 
    } 
    var it = bar(); 
    console.log( "outside:", it.next().value ); 
    // outside: A 
    console.log( "outside:", it.next( 1 ).value ); 
    // inside *bar(): 1 
    // outside: B 
    console.log( "outside:", it.next( 2 ).value ); 
    // outside: C 
    console.log( "outside:", it.next( 3 ).value ); 
    // outside: D 
    console.log( "outside:", it.next( 4 ).value ); 
    // inside *bar(): undefined 
    // outside: E 
    console.log( "outside:", it.next( 5 ).value ); 
    // inside *bar(): 5 
    // outside: F 
    ```
    - 注意这个例子和之前那个例子在消息接收位置和报告位置上的区别。最显著的是，默认的数组迭代器并不关心通过`next(..)`调用发送的任何消息，所以值 2、3和4根本就被忽略了。还有，因为迭代器没有显式的返回值（和前面使用的`*foo()`不同），所以`yield *`表达式完成后得到的是一个undefined
3.  异常也被委托
    - 和yield委托透明地双向传递消息的方式一样，错误和异常也是双向传递的
        ```javascript
        function *foo() { 
            try { 
                yield "B"; 
            } 
            catch (err) { 
                console.log( "error caught inside *foo():", err ); 
            } 
            yield "C"; 
            throw "D"; 
        } 
        function *bar() { 
            yield "A"; 
            try { 
                yield *foo(); 
            } 
            catch (err) { 
                console.log( "error caught inside *bar():", err ); 
            } 
            yield "E"; 
            yield *baz(); 
            // 注：不会到达这里！
            yield "G"; 
        } 
        function *baz() { 
            throw "F"; 
        } 
        var it = bar(); 
        console.log( "outside:", it.next().value ); 
        // outside: A 
        console.log( "outside:", it.next( 1 ).value ); 
        // outside: B 
        console.log( "outside:", it.throw( 2 ).value ); 
        // error caught inside *foo(): 2 
        // outside: C 
        console.log( "outside:", it.next( 3 ).value ); 
        // error caught inside *bar(): D 
        // outside: E 
        try { 
            console.log( "outside:", it.next( 4 ).value ); 
        } 
        catch (err) { 
            console.log( "error caught outside:", err ); 
        } 
        // error caught outside: F 
        ```
        - 这段代码中需要注意以下几点
        - 调用`it.throw(2)`时，它会发送错误消息2到`*bar()`，它又将其委托给`*foo()`，后者捕获并处理它。然后，`yield "C"`把"C"发送回去作为`it.throw(2)`调用返回的value
        - 接下来从`*foo()`内throw出来的值"D"传播到`*bar()`，这个函数捕获并处理它。然后`yield "E"`把"E"发送回去作为`it.next(3)`调用返回的value
        -  然后，从`*baz()`throw出来的异常并没有在`*bar()`内被捕获——所以`*baz()`和`*bar()`都被设置为完成状态。这段代码之后，就再也无法通过任何后续的`next(..)`调用得到值"G"，`next(..)`调用只会给value返回undefined

### 异步委托
1.  多个顺序Ajax请求的yield委托例子
    ```javascript
    function *foo() { 
        var r2 = yield request( "http://some.url.2" ); 
        var r3 = yield request( "http://some.url.3/?v=" + r2 ); 
        return r3; 
    } 
    function *bar() { 
        var r1 = yield request( "http://some.url.1" ); 
        var r3 = yield *foo(); 
        console.log( r3 ); 
    } 
    run( bar ); 
    ```
    - 这里我们在`*bar()`内部没有调用`yield run(foo)`，而是调用`yield *foo()`

### 递归委托
1.  yield委托可以跟踪任意多委托步骤，只要你把它们连在一起。甚至可以使用yield委托实现异步的生成器递归，即一个yield委托到它自身的生成器
    ```javascript
    function *foo(val) { 
        if (val > 1) { 
            // 生成器递归
            val = yield *foo( val - 1 ); 
        } 
        return yield request( "http://some.url/?v=" + val ); 
    } 
    function *bar() { 
        var r1 = yield *foo( 3 ); 
        console.log( r1 ); 
    } 
    run( bar );
    ```
    - `run(bar)`启动生成器`*bar()`
    - `foo(3)`创建了一个`*foo(..)`的迭代器，并传入3作为其参数val
    - 因为`3 > 1`，所以`foo(2)`创建了另一个迭代器，并传入2作为其参数val
    - 因为`2 > 1`，所以`foo(1)`又创建了一个新的迭代器，并传入1作为其参数val
    - 因为`1 > 1`不成立，所以接下来以值1调用`request(..)`，并从这第一个Ajax调用得到一个promise
    - 这个promise通过yield传出，回到`*foo(2)`生成器实例
    - `yield *`把这个promise传出回到`*foo(3)`生成器实例。另一个`yield *`把这个promise传出回到`*bar()`生成器实例。再有一个`yield *`把这个promise传出回到run(..)工具，这个工具会等待这个promsie（第一个Ajax请求）的处理
    - 这个promise决议后，它的完成消息会发送出来恢复`*bar()`；后者通过`yield *`转入`*foo(3)`实例；后者接着通过`yield *`转入`*foo(2)`生成器实例；后者再接着通过`yield *`转入`*foo(1)`生成器实例内部的等待着的普通yield
    - 第一个调用的Ajax响应现在立即从`*foo(3)`生成器实例中返回。这个实例把值作为`*foo(2)`实例中`yield *`表达式的结果返回，赋给它的局部变量val
    - 在`*foo(2)`中，通过`request(..)`发送了第二个Ajax请求。它的promise通过yield发回给`*foo(1)`实例，然后通过`yield *`一路传递到`run(..)`（再次进行步骤 7）。这个promise决议后，第二个Ajax响应一路传播回到`*foo(2)`生成器实例，赋给它的局部变量val
    - 最后，通过`request(..)`发出第三个Ajax请求，它的promise传出到`run(..)`，然后它的决议值一路返回，然后return返回到`*bar()`中等待的`yield *`表达式
    - 相当于是先利用`val=1`的条件请求得到结果，然后用该结果`val=yield *foo(1)`继续用于请求结果，最后再用该结果`val=yield *foo(yield *foo(1))`继续请求得到最终结果
