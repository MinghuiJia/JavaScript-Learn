<!--
 * @Author: jiaminghui
 * @Date: 2023-01-30 15:47:15
 * @LastEditTime: 2023-01-30 18:18:17
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\异步和性能\生成器.md
 * @Description: 
-->
# 生成器的学习
ES6 生成器（generator）可以让代码变成一种顺序、看似同步的异步流程控制表达风格
## 打破完整运行
1.  JavaScript开发者在代码中几乎普遍依赖的一个假定：一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。ES6引入了一个新的函数类型，它并不符合这种运行到结束的特性。这类新的函数被称为生成器
    ```javascript
    var x = 1; 
    function foo() { 
        x++; 
        bar(); // <-- 这一行是什么作用？
        console.log( "x:", x ); 
    } 
    function bar() { 
        x++; 
    } 
    foo(); // x: 3 
    ```
    - 在这个例子中，我们确信`bar()`会在`x++`和`console.log(x)`之间运行。但是，如果`bar()`并不在那里会怎样呢？显然结果就会是2，而不是3
    - 如果`bar()`并不在那儿，在抢占式多线程语言中，`bar()`可以在`x++`和`console.log(x)`语句之间打断并运行。但JavaScript并不是抢占式的，（目前）也不是多线程的。然而，如果`foo()`自身可以通过某种形式在代码的这个位置指示暂停的话，那就仍然可以以一种合作式的方式实现这样的中断（并发）
    - 下面是实现这样的合作式并发的ES6代码
        ```javascript
        var x = 1; 
        function *foo() { 
            x++; 
            yield; // 暂停！
            console.log( "x:", x ); 
        } 
        function bar() { 
            x++; 
        } 
        ```
    - 现在，我们要如何运行前面的代码片段，使得`bar()`在`*foo()`内部的yield处执行呢
        ```javascript
        // 构造一个迭代器it来控制这个生成器
        var it = foo(); 
        // 这里启动foo()！
        it.next(); 
        x; // 2 
        bar(); 
        x; // 3 
        it.next(); // x: 3 
        ```
        - `it = foo()`运算并没有执行生成器`*foo()`，而只是构造了一个迭代器（iterator），这个迭代器会控制它的执行
        - 第一个`it.next()`启动了生成器`*foo()`，并运行了`*foo()`第一行的`x++`
        - `*foo()`在yield语句处暂停，在这一点上第一个`it.next()`调用结束。此时`*foo()`仍在运行并且是活跃的，但处于暂停状态
        - 我们查看x的值，此时为2
        - 我们调用`bar()`，它通过`x++`再次递增x
        - 我们再次查看x的值，此时为3
        - 最后的`it.next()`调用从暂停处恢复了生成器`*foo()`的执行，并运行`console.log(..)`语句，这条语句使用当前x的值3
        - 显然，`foo()`启动了，但是没有完整运行，它在yield处暂停了。后面恢复了foo()并让它运行到结束，但这不是必需的
    - 因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成
### 输入和输出
1.  生成器函数是一个特殊的函数，但是，它仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。比如，它仍然可以接受参数（即输入），也能够返回值（即输出）
    ```javascript
    function *foo(x,y) { 
        return x * y; 
    } 
    var it = foo( 6, 7 ); 
    var res = it.next(); 
    res.value; // 42
    ```
    - 我们向`*foo(..)`传入实参6和7分别作为参数x和y。`*foo(..)`向调用代码返回42
    - 现在我们可以看到生成器和普通函数在调用上的一个区别。生成器`*foo(..)`并没有像普通函数一样实际运行
    - 事实上，我们只是创建了一个迭代器对象，把它赋给了一个变量it，用于控制生成器`*foo(..)`。然后调用`it.next()`，指示生成器`*foo(..)`从当前位置开始继续运行，停在下一个yield处或者直到生成器结束
    - 这个next(..)调用的结果是一个对象，它有一个value属性，持有从`*foo(..)`返回的值（如果有的话）。换句话说，yield会导致生成器在执行过程中发送出一个值，这有点类似于中间的return
2.  除了能够接受参数并提供返回值之外，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过yield和next(..)实现
    ```javascript
    function *foo(x) { 
        var y = x * (yield); 
        return y; 
    } 
    var it = foo( 6 ); 
    // 启动foo(..) 
    it.next(); 
    var res = it.next( 7 ); 
    res.value; // 42
    ```
    - 首先，传入6作为参数x。然后调用`it.next()`，这会启动`*foo(..)`
    - 在`*foo(..)`内部，开始执行语句`var y = x ..`，但随后就遇到了一个yield表达式。它就会在这一点上暂停`*foo(..)`（在赋值语句中间！），并在本质上要求调用代码为yield表达式提供一个结果值
    - 接下来，调用`it.next( 7 )`，这一句把值7传回作为被暂停的yield表达式的结果。所以，这时赋值语句实际上就是`var y = 6 * 7`。现在，`return y`返回值42作为调用`it.next( 7 )`的结果
    - 注意：yield和`next(..)`调用有一个不匹配。一般来说，需要的`next(..)`调用要比yield语句多一个，前面的代码片段有一个yield和两个`next(..)`调用。因为第一个`next(..)`总是启动一个生成器，并运行到第一个yield处。不过，是第二个`next(..)`调用完成第一个被暂停的yield表达式，第三个`next(..)`调用完成第二个yield，以此类推
3.  只考虑生成器代码
    ```javascript
    var y = x * (yield); 
    return y; 
    ```
    - 第一个yield基本上是提出了一个问题：“这里我应该插入什么值？”
    - 谁来回答这个问题呢？第一个`next()`已经运行，使得生成器启动并运行到此处，所以显然它无法回答这个问题。因此必须由第二个`next(..)`调用回答第一个yield提出的这个问题，这里的不匹配就是第二个对第一个
    - 不从生成器的视角看这个问题，而是从迭代器的角度。消息是双向传递的——`yield..`作为一个表达式可以发出消息响应`next(..)`调用，`next(..)`也可以向暂停的yield表达式发送值
        ```javascript
        function *foo(x) { 
            var y = x * (yield "Hello"); // <-- yield一个值！
            return y; 
        } 
        var it = foo( 6 ); 
        var res = it.next(); // 第一个next()，并不传入任何东西
        res.value; // "Hello" 
        res = it.next( 7 ); // 向等待的yield传入7
        res.value; // 42 
        ```
        - `yield ..`和`next(..)`这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统
        - 第一个`next()`调用（没有参数的）基本上就是在提出一个问题：“生成器`*foo(..)`要给我的下一个值是什么”。谁来回答这个问题呢？第一个`yield "hello"`表达式
        - 但是，与yield语句的数量相比，还是多出了一个额外的`next()`。所以，最后一个`it.next(7)`调用再次提出了这样的问题：生成器将要产生的下一个值是什么。但是，再没有yield语句来回答这个问题了，那么return语句回答这个问题
        - 如果你的生成器中没有return的话——在生成器中和在普通函数中一样，return当然不是必需的——总有一个假定的/隐式的return;（也就是`return undefined;`），它会在默认情况下回答最后的`it.next(7)`调用提出的问题
### 多个迭代器
1.  从语法使用的方面来看，通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。但有一个细微之处很容易忽略：每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互
    ```javascript
    function *foo() { 
        var x = yield 2; 
        z++; 
        var y = yield (x * z); 
        console.log( x, y, z ); 
    } 
    var z = 1; 
    var it1 = foo(); 
    var it2 = foo(); 
    var val1 = it1.next().value; // 2 <-- yield 2 
    var val2 = it2.next().value; // 2 <-- yield 2 
    val1 = it1.next( val2 * 10 ).value; // 40 <-- x:20, z:2 
    val2 = it2.next( val1 * 5 ).value; // 600 <-- x:200, z:3 
    it1.next( val2 / 2 ); // y:300 
    // 20 300 3 
    it2.next( val1 / 4 ); // y:10 
    // 200 10 3
    ```
2.  交替执行
    ```javascript
    var a = 1; 
    var b = 2; 
    function foo() { 
        a++; 
        b = b * a; 
        a = b + 3; 
    } 
    function bar() { 
        b--; 
        a = 8 + b; 
        b = a * 2; 
    } 
    ```
    - 如果是普通的JavaScript函数的话，显然，要么是`foo()`首先运行完毕，要么是`bar()`首先运行完毕，但`foo()`和`bar()`的语句不能交替执行。所以，前面的程序只有两种可能的输出
    - 但是，使用生成器的话，交替执行（甚至在语句当中！）显然是可能的
        ```javascript
        var a = 1; 
        var b = 2; 
        function *foo() { 
            a++; 
            yield; 
            b = b * a; 
            a = (yield b) + 3; 
        } 
        function *bar() { 
            b--; 
            yield; 
            a = (yield 8) + b; 
            b = a * (yield 2); 
        } 
        ```
        - 根据迭代器控制的`*foo()`和`*bar()`调用的相对顺序不同，前面的程序可能会产生多种不同的结果。换句话说，通过两个生成器在共享的相同变量上的迭代交替执行，我们实际上可以（以某种模拟的方式）印证第1章讨论的理论上的多线程竞态条件环境
    - 首先，来构建一个名为`step(..)`的辅助函数，用于控制迭代器
        ```javascript
        function step(gen) { 
            var it = gen(); 
            var last; 
            return function() { 
                // 不管yield出来的是什么，下一次都把它原样传回去！
                last = it.next( last ).value; 
            }; 
        } 
        ```
        - `step(..)`初始化了一个生成器来创建迭代器it，然后返回一个函数，这个函数被调用的时候会将迭代器向前迭代一步。另外，前面的yield发出的值会在下一步发送回去。于是，`yield 8`就是8，而`yield b`就是b（yield发出时的值）
    - 现在，我们来试验一下交替运行`*foo()`和`*bar()`代码块的效果
        - 确保`*foo()`在`*bar()`之前完全结束
            ```javascript
            // 确保重新设置a和b 
            a = 1; 
            b = 2; 
            var s1 = step( foo ); 
            var s2 = step( bar ); 
            // 首次运行*foo()
            s1(); 
            s1(); 
            s1(); 
            // 现在运行*bar() 
            s2(); 
            s2(); 
            s2(); 
            s2(); 
            console.log( a, b ); // 11 22
            ```
        - 现在交替执行顺序，看看a和b的值是如何改变的
            ```javascript
            // 确保重新设置a和b
            a = 1; 
            b = 2; 
            var s1 = step( foo ); 
            var s2 = step( bar ); 
            s2(); // b--; 
            s2(); // yield 8  
            s1(); // a++; 
            s2(); // a = 8 + b; 
            // yield 2 
            s1(); // b = b * a; 
            // yield b 
            s1(); // a = b + 3; 
            s2(); // b = a * 2; 
            console.log( a, b ); // 12 18 
            ```
            - 为什么最后在执行`s1();s2();`之前a和b均为9，但是再次执行`s1();s2();`两个表达式的顺序并不会影响a和b的值，是因为，在迭代器让生成器继续运行之前，表达式已经将上一次执行结果a和b均为9的值带入到表达式，所以即使先执行`s1();`后对a的值进行了更新，但是并不会影响`s2();`中`b = a * 2`中的a，a的值还是9，而不是更新后的12

## 生成器产生值
### 生产者与迭代器
1.  假定你要产生一系列值，其中每个值都与前面一个有特定的关系。要实现这一点，需要一个有状态的生产者能够记住其生成的最后一个值
    - 可以实现一个直接使用函数闭包的版本
        ```javascript
        var gimmeSomething = (function(){ 
            var nextVal; 
            return function(){ 
                if (nextVal === undefined) { 
                    nextVal = 1; 
                } 
                else { 
                    nextVal = (3 * nextVal) +6; 
                } 
                return nextVal; 
            }; 
        })(); 
        gimmeSomething(); // 1 
        gimmeSomething(); // 9 
        gimmeSomething(); // 33 
        gimmeSomething(); // 105 
        ```
2.  实际上，这个任务是一个非常通用的设计模式，通常通过迭代器来解决。迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值。JavaScript迭代器的接口，与多数语言类似，就是每次想要从生产者得到下一个值的时候调用`next()`
    - 可以为我们的数字序列生成器实现标准的迭代器接口
        ```javascript
        var something = (function(){ 
            var nextVal; 
            return { 
                // for..of循环需要
                [Symbol.iterator]: function(){ return this; }, 
                // 标准迭代器接口方法
                next: function(){ 
                    if (nextVal === undefined) { 
                        nextVal = 1; 
                    } 
                    else { 
                        nextVal = (3 * nextVal) + 6; 
                    } 
                    return { done:false, value:nextVal }; 
                } 
            }; 
        })(); 
        something.next().value; // 1 
        something.next().value; // 9 
        something.next().value; // 33 
        something.next().value; // 105 
        ```
        - `next()`调用返回一个对象。这个对象有两个属性：done是一个boolean值，标识迭代器的完成状态；value中放置迭代值
    - ES6还新增了一个`for..of`循环，这意味着可以通过原生循环语法自动迭代标准迭代器
        ```javascript
        for (var v of something) { 
            console.log( v ); 
            // 不要死循环！
            if (v > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969
        ```
        - 因为我们的迭代器something总是返回`done:false`，因此这个`for..of`循环将永远运行下去。但是也有一些情况下，迭代器会在有限的值集合上运行，并最终返回`done:true`
        - `for..of`循环在每次迭代中自动调用`next()`，它不会向`next()`传入任何值，并且会在接收到`done:true`之后自动停止
    - 当然，也可以手工在迭代器上循环，调用`next()`并检查`done:true`条件来确定何时停止循环
        ```javascript
        for ( 
            var ret; 
            (ret = something.next()) && !ret.done; 
        ) { 
            console.log( ret.value ); 
            // 不要死循环！
            if (ret.value > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969 
        ```
        - 这种手工for方法当然要比ES6的`for..of`循环语法丑陋，但其优点是，这样就可以在需要时向`next()`传递值
3.  除了构造自己的迭代器，许多JavaScript的内建数据结构（从ES6开始），比如array，也有默认的迭代器
    ```javascript
    var a = [1,3,5,7,9]; 
    for (var v of a) { 
        console.log( v ); 
    } 
    // 1 3 5 7 9 
    ```
    - 不过一般的object是故意不像array一样有默认的迭代器。如果你只是想要迭代一个对象的所有属性的话（不需要保证特定的顺序），可以通过`Object.keys(..)`返回一个array，类似于`for (var k of Object.keys(obj)) { ..`这样使用。这样在一个对象的键值上使用`for..of`循环与`for..in`循环类似。`Object.keys(..)`并不包含来自于`[[Prototype]]`链上的属性，而`for..in`则包含
### iterable
1.  前面例子中的something对象叫作迭代器，因为它的接口中有一个`next()`方法。而与其紧密相关的一个术语是iterable（可迭代），即指一个包含可以在其值上迭代的迭代器的对象
2.  从ES6开始，从一个iterable中提取迭代器的方法是：iterable必须支持一个函数，其名称是专门的ES6符号值`Symbol.iterator`。调用这个函数时，它会返回一个迭代器。通常每次调用会返回一个全新的迭代器，虽然这一点并不是必须的
    - 前面代码片段中的a就是一个iterable。`for..of`循环自动调用它的`Symbol.iterator`函数来构建一个迭代器。我们当然也可以手工调用这个函数，然后使用它返回的迭代器
        ```javascript
        var a = [1,3,5,7,9]; 
        var it = a[Symbol.iterator](); 
        it.next().value; // 1 
        it.next().value; // 3 
        it.next().value; // 5 
        .. 
        ```
    - 前面的代码中列出了定义的something，你可能已经注意到了这一行`[Symbol.iterator]: function(){ return this; } `
        - 将something的值（迭代器something的接口）也构建成为一个iterable。现在它既是iterable，也是迭代器。然后我们把something传给`for..of`循环
            ```javascript
            for (var v of something) { 
                .. 
            } 
            ```
            - `for..of`循环期望something是iterable，于是它寻找并调用它的`Symbol.iterator`函数。我们将这个函数定义为就是简单的`return this`，也就是把自身返回，而`for..of`循环并不知情
### 生成器迭代器
1.  可以把生成器看作一个值的生产者，我们通过迭代器接口的`next()`调用一次提取出一个值
    - 所以，严格说来，生成器本身并不是iterable，尽管非常类似——当你执行一个生成器，就得到了一个迭代器
        ```javascript
        function *foo(){ .. } 
        var it = foo();
        ```
    - 可以通过生成器实现前面的这个something无限数字序列生产者，类似这样
        ```javascript
        function *something() { 
            var nextVal; 
            while (true) { 
                if (nextVal === undefined) { 
                    nextVal = 1; 
                } 
                else { 
                    nextVal = (3 * nextVal) + 6; 
                } 
                yield nextVal; 
            } 
        } 
        ```
        - 因为生成器会在每个yield处暂停，函数`*something()`的状态（作用域）会被保持，即意味着不需要闭包在调用之间保持变量状态
    - 现在，可以通过`for..of`循环使用我们雕琢过的新的`*something()`生成器。你可以看到，其工作方式基本是相同的
        ```javascript
        for (var v of something()) { 
            console.log( v ); 
            // 不要死循环！
            if (v > 500) { 
                break; 
            } 
        } 
        // 1 9 33 105 321 969 
        ```
        - 但是，不要忽略了这段`for (var v of something()) ..`！我们并不是像前面的例子那样把something当作一个值来引用，而是调用了`*something()`生成器以得到它的迭代器供`for..of`循环使用。而之前的代码是将something当作一个iterable
        - `something()`·`调用产生一个迭代器，但`for..of`循环需要的是一个iterable，对吧？是的。生成器的迭代器也有一个`Symbol.iterator`函数，基本上这个函数做的就是`return this`，和我们前面定义的iterable`something`一样。换句话说，生成器的迭代器也是一个iterable
2.  停止生成器
    - 在前面的例子中，看起来似乎`*something()`生成器的迭代器实例在循环中的break调用之后就永远留在了挂起状态。其实有一个隐藏的特性会帮助你管理此事。`for..of`循环的“异常结束”（也就是“提前终止”），通常由break、return或者未捕获异常引起，会向生成器的迭代器发送一个信号使其终止
    - 严格地说，在循环正常结束之后，`for..of`循环也会向迭代器发送这个信号
    - 尽管`for..of`循环会自动发送这个信号，但你可能会希望向一个迭代器手工发送这个信号。可以通过调用`return(..)`实现这一点。如果在生成器内有`try..finally`语句，它将总是运行，即使生成器已经外部结束。如果需要清理资源的话（数据库连接等），这一点非常有用
        ```javascript
        function *something() { 
            try { 
                var nextVal; 
                while (true) { 
                    if (nextVal === undefined) { 
                        nextVal = 1; 
                    } 
                    else { 
                        nextVal = (3 * nextVal) + 6; 
                    } 
                    yield nextVal; 
                } 
            } 
            // 清理子句
            finally { 
                console.log( "cleaning up!" ); 
            } 
        } 
        ```
        - 之前的例子中，`for..of`循环内的break会触发finally语句。但是，也可以在外部通过`return(..)`手工终止生成器的迭代器实例
            ```javascript
            var it = something(); 
            for (var v of it) { 
                console.log( v ); 
                // 不要死循环！
                if (v > 500) { 
                    console.log( 
                        // 完成生成器的迭代器
                        it.return( "Hello World" ).value 
                    ); 
                    // 这里不需要break 
                } 
            } 
            // 1 9 33 105 321 969
            // 清理！
            // Hello World 
            ```
            - 调用`it.return(..)`之后，它会立即终止生成器，这当然会运行finally语句。另外，它还会把返回的value设置为传入`return(..)`的内容，这也就是`"Hello World"`被传出去的过程。现在我们也不需要包含break语句了，因为生成器的迭代器已经被设置为`done:true`，所以`for..of`循环会在下一个迭代终止