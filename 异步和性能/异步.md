<!--
 * @Author: jiaminghui
 * @Date: 2023-01-14 21:10:40
 * @LastEditTime: 2023-01-14 22:46:21
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\异步和性能\异步.md
 * @Description: 
-->
# 异步的学习
程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心

## 异步
### 分块的程序
1.  程序中将来执行的部分并不一定在现在运行的部分执行完之后就立即执行。换句话说，现在无法完成的任务将会异步完成，因此并不会出现人们本能地认为会出现的或希望出现的阻塞行为
    ```javascript
    // ajax(..)是某个库中提供的某个Ajax函数
    var data = ajax( "http://some.url.1" );
    console.log( data );
    // 啊哦！data通常不会包含Ajax结果
    ```
    - 标准Ajax请求不是同步完成的，这意味着`ajax(..)`函数还没有返回任何值可以赋给变量data。如果`ajax(..)`能够阻塞到响应返回，那么`data = ..`赋值就会正确工作
    - Ajax的使用方法是，我们发出一个异步Ajax请求，然后在将来才能得到返回的结果
2.  从现在到将来的“等待”，最简单的方法（但绝对不是唯一的，甚至也不是最好的！）是使用一个通常称为回调函数的函数
    ```javascript
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", function myCallbackFunction(data){
        console.log( data ); // 耶！这里得到了一些数据！
    } );
    ```
    - 技术上可以发送同步Ajax请求，但在任何情况下都不应该使用这种方式，因为它会锁定浏览器UI（按钮、菜单、滚动条等），并阻塞所有的用户交互
3.  程序中的现在执行的部分，以及将来执行的部分
    ```javascript
    function now() {
        return 21;
    }
    function later() {
        answer = answer * 2;
        console.log( "Meaning of life:", answer );
    }
    var answer = now();
    setTimeout( later, 1000 ); // Meaning of life: 42
    ```
    - 这个程序有两个块：现在执行的部分，以及将来执行的部分

    ```javascript
    // 现在
    function now() {
        return 21;
    }
    function later() { .. }
    var answer = now();
    setTimeout( later, 1000 );

    // 将来
    answer = answer * 2;
    console.log( "Meaning of life:", answer );
    ```
    - 现在这一块在程序运行之后就会立即执行。但是，`setTimeout(..)`还设置了一个事件（定时）在将来执行，所以函数`later()`的内容会在之后的某个时间（从现在起1000毫秒之后）执行
    - 任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制
4.  异步控制台
    - 在某些条件下，某些浏览器的`console.log(..)`并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O是非常低速的阻塞部分。所以，（从页面/UI的角度来说）浏览器在后台异步处理控制台I/O能够提高性能，这时用户甚至可能根本意识不到其发生
    - 到底什么时候控制台I/O会延迟，甚至是否能够被观察到，这都是游移不定的。如果在调试的过程中遇到对象在`console.log(..)`语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种I/O的异步化造成的

### 事件循环
1.  JavaScript引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是Web浏览器。经过最近几年（不仅于此）的发展，JavaScript已经超出了浏览器的范围，进入了其他环境，比如通过像Node.js这样的工具进入服务器领域。实际上，JavaScript现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中
2.  但是，所有这些环境都有一个共同“点”（thread，也指线程），即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用JavaScript引擎，这种机制被称为事件循环
    - JavaScript引擎本身并没有时间的概念，只是一个按需执行JavaScript任意代码片段的环境。“事件”（JavaScript代码执行）调度总是由包含它的环境进行
    - 如果你的JavaScript程序发出一个Ajax请求，从服务器获取一些数据，那你就在一个函数（通常称为回调函数）中设置好响应代码，然后JavaScript引擎会通知宿主环境：“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数。”。然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行
3.  什么是事件循环
    ```javascript
    // eventLoop是一个用作队列的数组
    // （先进，先出）
    var eventLoop = [ ];
    var event;
    // “永远”执行
    while (true) {
        // 一次tick
        if (eventLoop.length > 0) {
            // 拿到队列中的下一个事件
            event = eventLoop.shift();
            // 现在，执行下一个事件
            try {
                event();
            }
            catch (err) {
                reportError(err);
            }
        }
    }
    ```
    - 上述是一段极度简化的伪代码用于解释事件循环
    - 有一个用while循环实现的持续运行的循环，循环的每一轮称为一个tick。对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数
    - `setTimeout(..)`并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的tick会摘下并执行这个回调
    - 如果这时候事件循环中已经有20个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么`setTimeout(..)`定时器的精度可能不高。可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定

### 并行线程
1.  术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情
2.  并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行，但多个线程能够共享单个进程的内存。与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存
3.  并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的
    ```javascript
    function later() { 
        answer = answer * 2; 
        console.log( "Meaning of life:", answer ); 
    } 
    ```
    - 尽管`later()`的所有内容被看作单独的一个事件循环队列表项，但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。比如，`answer = answer * 2`需要先加载answer的当前值，然后把2放到某处并执行乘法，取得结果之后保存回answer中
    - 在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。但如果是在并行系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果


    ```javascript
    var a = 20; 
    function foo() { 
        a = a + 1; 
    } 
    function bar() { 
        a = a * 2; 
    } 
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );
    ```
    - 根据JavaScript的单线程运行特性，如果`foo()`运行在`bar()`之前，a的结果是42，而如果`bar()`运行在`foo()`之前的话，a的结果就是41

    - 如果共享同一数据的JavaScript事件并行执行的话，那么问题就变得更加微妙了，`foo()`和`bar()`中代码运行的线程分别执行的是以下两段伪代码任务
        ```
        线程 1（X 和 Y 是临时内存地址）：
            foo(): 
                a. 把a的值加载到X 
                b. 把1保存在Y 
                c. 执行X加Y，结果保存在X 
                d. 把X的值保存在a 
        线程 2（X 和 Y 是临时内存地址）：
            bar(): 
                a. 把a的值加载到X 
                b. 把2保存在Y 
                c. 执行X乘Y，结果保存在X 
                d. 把X的值保存在a 
        ```
        - 它们在临时步骤中使用了共享的内存地址X和Y，并且不同的执行顺序会产生不同的结果
        
        ```
        执行顺序1：
            1a (把a的值加载到X ==> 20) 
            2a (把a的值加载到X ==> 20) 
            1b (把1保存在Y ==> 1) 
            2b (把2保存在Y ==> 2) 
            1c (执行X加Y，结果保存在X ==> 22) 
            1d (把X的值保存在a ==> 22) 
            2c (执行X乘Y，结果保存在X ==> 44) 
            2d (把X的值保存在a ==> 44) 
            a的结果将是44
        执行顺序2：
            1a (把a的值加载到X ==> 20) 
            2a (把a的值加载到X ==> 20) 
            2b (把2保存在Y ==> 2) 
            1b (把1保存在Y ==> 1) 
            2c (执行X乘Y，结果保存在X ==> 20) 
            1c (执行X加Y，结果保存在X ==> 21) 
            1d (把X的值保存在a ==> 21) 
            2d (把X的值保存在a ==> 21)
            a的结果将是21
        ```
        - 所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为
    - JavaScript从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着JavaScript总是确定性的
4.  由于JavaScript的单线程特性，`foo()`（以及`bar()`）中的代码具有原子性。也就是说，一旦`foo()`开始运行，它的所有代码都会在`bar()`中的任意代码运行之前完成，这称为完整运行（run-to-completion）特性
    ```javascript
    var a = 1; 
    var b = 2; 
    function foo() { 
        a++; 
        b = b * a; 
        a = b + 3; 
    } 
    function bar() { 
        b--; 
        a = 8 + b; 
        b = a * 2; 
    } 
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );
    ```
    - 由于`foo()`不会被`bar()`中断，`bar()`也不会被`foo()`中断，所以这个程序只有两个可能的输出，取决于这两个函数哪个先运行
    - 如果存在多线程，且`foo()`和`bar()`中的语句可以交替运行的话，可能输出的数目将会增加不少
    - 这个程序有两个可能输出，先执行`foo()`再执行`bar()`，返回`a==11;b==22`；限制性`bar()`再执行`foo()`，返回`a==183;b==180`，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别
    
    - 在JavaScript的特性中，这种函数顺序的不确定性就是通常所说的竞态条件（racecondition），`foo()`和`bar()`相互竞争，看谁先运行
