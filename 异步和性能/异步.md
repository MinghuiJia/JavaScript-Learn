<!--
 * @Author: jiaminghui
 * @Date: 2023-01-14 21:10:40
 * @LastEditTime: 2023-01-18 22:01:44
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\异步和性能\异步.md
 * @Description: 
-->
# 异步的学习
程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心

## 异步
### 分块的程序
1.  程序中将来执行的部分并不一定在现在运行的部分执行完之后就立即执行。换句话说，现在无法完成的任务将会异步完成，因此并不会出现人们本能地认为会出现的或希望出现的阻塞行为
    ```javascript
    // ajax(..)是某个库中提供的某个Ajax函数
    var data = ajax( "http://some.url.1" );
    console.log( data );
    // 啊哦！data通常不会包含Ajax结果
    ```
    - 标准Ajax请求不是同步完成的，这意味着`ajax(..)`函数还没有返回任何值可以赋给变量data。如果`ajax(..)`能够阻塞到响应返回，那么`data = ..`赋值就会正确工作
    - Ajax的使用方法是，我们发出一个异步Ajax请求，然后在将来才能得到返回的结果
2.  从现在到将来的“等待”，最简单的方法（但绝对不是唯一的，甚至也不是最好的！）是使用一个通常称为回调函数的函数
    ```javascript
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", function myCallbackFunction(data){
        console.log( data ); // 耶！这里得到了一些数据！
    } );
    ```
    - 技术上可以发送同步Ajax请求，但在任何情况下都不应该使用这种方式，因为它会锁定浏览器UI（按钮、菜单、滚动条等），并阻塞所有的用户交互
3.  程序中的现在执行的部分，以及将来执行的部分
    ```javascript
    function now() {
        return 21;
    }
    function later() {
        answer = answer * 2;
        console.log( "Meaning of life:", answer );
    }
    var answer = now();
    setTimeout( later, 1000 ); // Meaning of life: 42
    ```
    - 这个程序有两个块：现在执行的部分，以及将来执行的部分

    ```javascript
    // 现在
    function now() {
        return 21;
    }
    function later() { .. }
    var answer = now();
    setTimeout( later, 1000 );

    // 将来
    answer = answer * 2;
    console.log( "Meaning of life:", answer );
    ```
    - 现在这一块在程序运行之后就会立即执行。但是，`setTimeout(..)`还设置了一个事件（定时）在将来执行，所以函数`later()`的内容会在之后的某个时间（从现在起1000毫秒之后）执行
    - 任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制
4.  异步控制台
    - 在某些条件下，某些浏览器的`console.log(..)`并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O是非常低速的阻塞部分。所以，（从页面/UI的角度来说）浏览器在后台异步处理控制台I/O能够提高性能，这时用户甚至可能根本意识不到其发生
    - 到底什么时候控制台I/O会延迟，甚至是否能够被观察到，这都是游移不定的。如果在调试的过程中遇到对象在`console.log(..)`语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种I/O的异步化造成的

### 事件循环
1.  JavaScript引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是Web浏览器。经过最近几年（不仅于此）的发展，JavaScript已经超出了浏览器的范围，进入了其他环境，比如通过像Node.js这样的工具进入服务器领域。实际上，JavaScript现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中
2.  但是，所有这些环境都有一个共同“点”（thread，也指线程），即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用JavaScript引擎，这种机制被称为事件循环
    - JavaScript引擎本身并没有时间的概念，只是一个按需执行JavaScript任意代码片段的环境。“事件”（JavaScript代码执行）调度总是由包含它的环境进行
    - 如果你的JavaScript程序发出一个Ajax请求，从服务器获取一些数据，那你就在一个函数（通常称为回调函数）中设置好响应代码，然后JavaScript引擎会通知宿主环境：“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数。”。然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行
3.  什么是事件循环
    ```javascript
    // eventLoop是一个用作队列的数组
    // （先进，先出）
    var eventLoop = [ ];
    var event;
    // “永远”执行
    while (true) {
        // 一次tick
        if (eventLoop.length > 0) {
            // 拿到队列中的下一个事件
            event = eventLoop.shift();
            // 现在，执行下一个事件
            try {
                event();
            }
            catch (err) {
                reportError(err);
            }
        }
    }
    ```
    - 上述是一段极度简化的伪代码用于解释事件循环
    - 有一个用while循环实现的持续运行的循环，循环的每一轮称为一个tick。对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数
    - `setTimeout(..)`并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的tick会摘下并执行这个回调
    - 如果这时候事件循环中已经有20个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么`setTimeout(..)`定时器的精度可能不高。可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定

### 并行线程
1.  术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情
2.  并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行，但多个线程能够共享单个进程的内存。与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存
3.  并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的
    ```javascript
    function later() { 
        answer = answer * 2; 
        console.log( "Meaning of life:", answer ); 
    } 
    ```
    - 尽管`later()`的所有内容被看作单独的一个事件循环队列表项，但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。比如，`answer = answer * 2`需要先加载answer的当前值，然后把2放到某处并执行乘法，取得结果之后保存回answer中
    - 在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。但如果是在并行系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果


    ```javascript
    var a = 20; 
    function foo() { 
        a = a + 1; 
    } 
    function bar() { 
        a = a * 2; 
    } 
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );
    ```
    - 根据JavaScript的单线程运行特性，如果`foo()`运行在`bar()`之前，a的结果是42，而如果`bar()`运行在`foo()`之前的话，a的结果就是41

    - 如果共享同一数据的JavaScript事件并行执行的话，那么问题就变得更加微妙了，`foo()`和`bar()`中代码运行的线程分别执行的是以下两段伪代码任务
        ```
        线程 1（X 和 Y 是临时内存地址）：
            foo(): 
                a. 把a的值加载到X 
                b. 把1保存在Y 
                c. 执行X加Y，结果保存在X 
                d. 把X的值保存在a 
        线程 2（X 和 Y 是临时内存地址）：
            bar(): 
                a. 把a的值加载到X 
                b. 把2保存在Y 
                c. 执行X乘Y，结果保存在X 
                d. 把X的值保存在a 
        ```
        - 它们在临时步骤中使用了共享的内存地址X和Y，并且不同的执行顺序会产生不同的结果
        
        ```
        执行顺序1：
            1a (把a的值加载到X ==> 20) 
            2a (把a的值加载到X ==> 20) 
            1b (把1保存在Y ==> 1) 
            2b (把2保存在Y ==> 2) 
            1c (执行X加Y，结果保存在X ==> 22) 
            1d (把X的值保存在a ==> 22) 
            2c (执行X乘Y，结果保存在X ==> 44) 
            2d (把X的值保存在a ==> 44) 
            a的结果将是44
        执行顺序2：
            1a (把a的值加载到X ==> 20) 
            2a (把a的值加载到X ==> 20) 
            2b (把2保存在Y ==> 2) 
            1b (把1保存在Y ==> 1) 
            2c (执行X乘Y，结果保存在X ==> 20) 
            1c (执行X加Y，结果保存在X ==> 21) 
            1d (把X的值保存在a ==> 21) 
            2d (把X的值保存在a ==> 21)
            a的结果将是21
        ```
        - 所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为
    - JavaScript从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着JavaScript总是确定性的
4.  由于JavaScript的单线程特性，`foo()`（以及`bar()`）中的代码具有原子性。也就是说，一旦`foo()`开始运行，它的所有代码都会在`bar()`中的任意代码运行之前完成，这称为完整运行（run-to-completion）特性
    ```javascript
    var a = 1; 
    var b = 2; 
    function foo() { 
        a++; 
        b = b * a; 
        a = b + 3; 
    } 
    function bar() { 
        b--; 
        a = 8 + b; 
        b = a * 2; 
    } 
    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", foo ); 
    ajax( "http://some.url.2", bar );
    ```
    - 由于`foo()`不会被`bar()`中断，`bar()`也不会被`foo()`中断，所以这个程序只有两个可能的输出，取决于这两个函数哪个先运行
    - 如果存在多线程，且`foo()`和`bar()`中的语句可以交替运行的话，可能输出的数目将会增加不少
    - 这个程序有两个可能输出，先执行`foo()`再执行`bar()`，返回`a==11;b==22`；先执行`bar()`再执行`foo()`，返回`a==183;b==180`，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别
    
    - 在JavaScript的特性中，这种函数顺序的不确定性就是通常所说的竞态条件（racecondition），`foo()`和`bar()`相互竞争，看谁先运行

### 并发
1.  现在让我们来设想一个展示状态更新列表（比如社交网络新闻种子）的网站，其随着用户向下滚动列表而逐渐加载更多内容。要正确地实现这一特性，需要（至少）两个独立的“进程”同时运行（也就是说，是在同一段时间内，并不需要在同一时刻）
    - 第一个“进程”在用户向下滚动页面触发`onscroll`事件时响应这些事件（发起Ajax请求要求新的内容）
    - 第二个“进程”接收Ajax响应（把内容展示到页面）
    - 显然，如果用户滚动页面足够快的话，在等待第一个响应返回并处理的时候可能会看到两个或更多`onscroll`事件被触发，因此将得到快速触发彼此交替的`onscroll`事件和Ajax响应事件
    - 两个或多个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时运行）
    - **可以把并发看作“进程”级（或者任务级）的并行**，与运算级的并行（不同处理器上的线程）相对

2.  在给定的时间窗口内（用户滚动页面的几秒钟内），我们把各个独立的“进程”表示为一系列事件/运算
    ```
    “进程”1（onscroll 事件）：
        onscroll, 请求1 
        onscroll, 请求2 
        onscroll, 请求3 
        onscroll, 请求4 
        onscroll, 请求5 
        onscroll, 请求6 
        onscroll, 请求7 
    “进程”2（Ajax 响应事件）：
        响应1 
        响应2 
        响应3 
        响应4 
        响应5 
        响应6 
        响应7 
    ```
    - 很可能某个`onscroll`事件和某个`Ajax`响应事件恰好同时可以处理
        ```
        onscroll, 请求1 
        onscroll, 请求2     响应1 
        onscroll, 请求3     响应2 
        响应3 
        onscroll, 请求4 
        onscroll, 请求5 
        onscroll, 请求6     响应4 
        onscroll, 请求7 
        响应6 
        响应5 
        响应7 
        ```
        - 但是，本章前面介绍过事件循环的概念，JavaScript一次只能处理一个事件，所以要么是`onscroll，请求2`先发生，要么是响应1先发生，但是不会严格地同时发生
    
    - 下面列出了事件循环队列中所有这些交替的事件
        ```
        onscroll, 请求1     <--- 进程1启动
        onscroll, 请求2 
        响应1               <--- 进程2启动
        onscroll, 请求3 
        响应2 
        响应3 
        onscroll, 请求4 
        onscroll, 请求5 
        onscroll, 请求6 
        响应4 
        onscroll, 请求7     <--- 进程1结束
        响应6 
        响应5 
        响应7               <--- 进程2结束
        ```
        - “进程”1和“进程”2并发运行（任务级并行），但是它们的各个事件是在事件循环队列中依次运行的
        - 另外，注意到响应6和响应5的返回是乱序的了吗，这是因为单线程事件循环是并发的一种形式（当然还有其他形式）
3.  非交互
    - 两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互
    - 如果进程间没有相互影响的话，不确定性是完全可以接受的
        ```javascript
        var res = {}; 
        function foo(results) { 
            res.foo = results; 
        } 
        function bar(results) { 
            res.bar = results; 
        } 
        // ajax(..)是某个库提供的某个Ajax函数
        ajax( "http://some.url.1", foo ); 
        ajax( "http://some.url.2", bar ); 
        ```
        - `foo()`和`bar()`是两个并发执行的“进程”，按照什么顺序执行是不确定的。但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们是独立运行的，不会相互影响
4.  交互
    - 更常见的情况是，并发的“进程”需要相互交流，通过作用域或DOM间接交互，这就需要对它们的交互进行协调以避免竞态的出现
    - 下面是一个简单的例子，两个并发的“进程”通过隐含的顺序相互影响，这个顺序有时会被破坏
        ```javascript
        var res = []; 
        function response(data) { 
            res.push( data ); 
        } 
        // ajax(..)是某个库中提供的某个Ajax函数
        ajax( "http://some.url.1", response ); 
        ajax( "http://some.url.2", response ); 
        ```
        - 我们假定期望的行为是`res[0]`中放调用`"http://some.url.1"`的结果，`res[1]`中放调用`"http://some.url.2"`的结果。有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定
        - 执行的两个不同任务，比如一个执行数据库任务，而另一个只是获取静态文件，所以观察到的顺序总是第二个任务响应速度显著慢于第一个任务。即使两个请求都发送到同一个服务器，也总会按照固定的顺序响应，但对于响应返回浏览器的顺序，也没有人可以真正保证
        - 因此，可以协调交互顺序来处理这样的竞态条件：
            ```javascript
            var res = []; 
            function response(data) { 
                if (data.url == "http://some.url.1") { 
                    res[0] = data; 
                } 
                else if (data.url == "http://some.url.2") { 
                    res[1] = data; 
                } 
            } 
            // ajax(..)是某个库中提供的某个Ajax函数
            ajax( "http://some.url.1", response ); 
            ajax( "http://some.url.2", response ); 
            ```
            - 不管哪一个Ajax响应先返回，我们都要通过查看`data.url`（当然，假定从服务器总会返回一个！）判断应该把响应数据放在res数组中的什么位置上

        - 多个并发函数调用通过共享DOM彼此之间交互带来的竞态的解决方案可以仿照上述代码进行条件判断。（比如一个函数调用更新某个`<div>`的内容，另外一个更新这个`<div>`的风格或属性--比如使这个DOM元素一有内容就显示出来，可能你并不想在这个DOM元素在拿到内容之前显示出来，所以这种协调必须要保证正确的交互顺序）
    - 有些并发场景如果不做协调，就总是（并非偶尔）会出错
        ```javascript
        var a, b; 
        function foo(x) { 
            a = x * 2; 
            baz(); 
        } 
        function bar(y) { 
            b = y * 2; 
            baz(); 
        } 
        function baz() { 
            console.log(a + b); 
        } 
        // ajax(..)是某个库中的某个Ajax函数
        ajax( "http://some.url.1", foo ); 
        ajax( "http://some.url.2", bar ); 
        ```
        - 在这个例子中，无论`foo()`和`bar()`哪一个先被触发，总会使`baz()`过早运行（a或者b仍处于未定义状态）
        - 要解决这个问题有多种方法。这里给出了一种简单方法
            ```javascript
            var a, b; 
            function foo(x) { 
                a = x * 2; 
                if (a && b) { 
                    baz(); 
                } 
            } 
            function bar(y) { 
                b = y * 2; 
                if (a && b) { 
                    baz(); 
                } 
            } 
            function baz() { 
                console.log( a + b ); 
            } 
            // ajax(..)是某个库中的某个Ajax函数
            ajax( "http://some.url.1", foo ); 
            ajax( "http://some.url.2", bar ); 
            ```
            - 包裹`baz()`调用的条件判断`if (a && b)`传统上称为门（gate），我们虽然不能确定a和b到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用`baz()`）
    - 另一种可能遇到的并发交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者
        ```javascript
        var a; 
        function foo(x) { 
            a = x * 2; 
            baz(); 
        } 
        function bar(x) { 
            a = x / 2; 
            baz(); 
        } 
        function baz() { 
            console.log( a ); 
        } 
        // ajax(..)是某个库中的某个Ajax函数
        ajax( "http://some.url.1", foo ); 
        ajax( "http://some.url.2", bar ); 
        ```
        - 不管哪一个（`foo()`或`bar()`）后被触发，都不仅会覆盖另外一个给a赋的值，也会重复调用`baz()`（很可能并不是想要的结果），所以，可以通过一个简单的门闩协调这个交互过程，只让第一个通过
            ```javascript
            var a; 
            function foo(x) { 
                if (!a) { 
                    a = x * 2; 
                    baz(); 
                } 
            } 
            function bar(x) { 
                if (!a) { 
                    a = x / 2; 
                    baz(); 
                } 
            } 
            function baz() { 
                console.log( a ); 
            } 
            // ajax(..)是某个库中的某个Ajax函数
            ajax( "http://some.url.1", foo ); 
            ajax( "http://some.url.2", bar ); 
            ```
            - 条件判断`if (!a)`使得只有`foo()`和`bar()`中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略
5.  协作
    - 还有一种并发合作方式，称为并发协作（cooperative concurrency）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行
    - 举例来说，考虑一个需要遍历很长的结果列表进行值转换的Ajax响应处理函数。我们会使用`Array.map(..)`让代码更简洁
        ```javascript
        var res = []; 
        // response(..)从Ajax调用中取得结果数组
        function response(data) { 
            // 添加到已有的res数组
            res = res.concat( 
                // 创建一个新的变换数组把所有data值加倍
                data.map( function(val){ 
                    return val * 2; 
                } ) 
            ); 
        } 
        // ajax(..)是某个库中提供的某个Ajax函数
        ajax( "http://some.url.1", response ); 
        ajax( "http://some.url.2", response ); 
        ```
        - 如果`"http://some.url.1"`首先取得结果，那么整个列表会立刻映射到res中。如果有像1000万条记录的话，就可能需要运行相当一段时间了。这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的`response(..)`调用或UI刷新，甚至是像滚动、输入、按钮点击这样的用户事件。所以，要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。这里给出一种非常简单的方法
            ```javascript
            var res = []; 
            // response(..)从Ajax调用中取得结果数组
            function response(data) { 
                // 一次处理1000个
                var chunk = data.splice( 0, 1000 ); 
                // 添加到已有的res组
                res = res.concat( 
                    // 创建一个新的数组把chunk中所有值加倍
                    chunk.map( function(val){ 
                        return val * 2; 
                    } ) 
                ); 
                // 还有剩下的需要处理吗？
                if (data.length > 0) { 
                    // 异步调度下一次批处理
                    setTimeout( function(){ 
                        response( data ); 
                    }, 0 ); 
                } 
            } 
            // ajax(..)是某个库中提供的某个Ajax函数
            ajax( "http://some.url.1", response ); 
            ajax( "http://some.url.2", response ); 
            ```
            - `data.splice( 0, 1000 );`第一个参数是数组开始的索引下标，第二个参数是个数，splice函数会改变原数组，会把这1000个数据从data中删除
            - 我们把数据集合放在最多包含1000条项目的块中。这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点/App的响应（性能）
            - 当然，我们并没有协调这些“进程”的顺序，所以结果的顺序是不可预测的。如果需要排序的话，就要使用和前面提到类似的交互技术，或者本书后面章节将要介绍的技术
            - 这里使用`setTimeout(..0)`（hack）进行异步调度，基本上它的意思就是“把这个函数插入到当前事件循环队列的结尾处”
            - 严格说来，`setTimeout(..0)`并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的`setTimeout(..0)`调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测

### 任务
1.  在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列（job queue）。这个概念给大家带来的最大影响可能是Promise的异步特性
2.  对于任务队列最好的理解方式就是，它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目（一个任务）。这就像是在说：“哦，这里还有一件事将来要做，但要确保在其他任何事情发生之前就完成它。”。事件循环队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩
3.  一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环（job loop）可能无限循环（一个任务总是添加另一个任务，以此类推），进而导致程序的饿死，无法转移到下一个事件循环tick。从概念上看，这和代码中的无限循环（就像`while(true)..`）的体验几乎是一样的
4.  任务和`setTimeout(..0)`hack的思路类似，但是其实现方式的定义更加良好，对顺序的保证性更强：尽可能早的将来
5.  设想一个调度任务（直接地，不要hack）的API，称其为`schedule(..)`
    ```javascript
    console.log( "A" ); 
    setTimeout( function(){ 
        console.log( "B" ); 
    }, 0 ); 
    // 理论上的"任务API" 
    schedule( function(){ 
        console.log( "C" ); 
        schedule( function(){ 
            console.log( "D" ); 
        } ); 
    } ); 
    ```
    - 可能你认为这里会打印出`A B C D`，但实际打印的结果是`A C D B`。因为任务处理是在当前事件循环tick结尾处，且定时器触发是为了调度下一个事件循环tick
    - Promise的异步特性是基于任务的，所以一定要清楚它和事件循环特性的关系

### 语句顺序
1.  代码中语句的顺序和JavaScript引擎执行语句的顺序并不一定要一致。但是JavaScript代码已经从程序的角度在语序方面规定了可预测和非常可靠的特性。所以，接下来我们要讨论的内容应该无法在自己的JavaScript程序中观察到
    - 例如下面代码
        ```javascript
        var a, b; 
        a = 10; 
        b = 30; 
        a = a + 1; 
        b = b + 1; 
        console.log( a + b ); // 42
        ```
        - 这段代码中没有显式的异步（除了前面介绍过的很少见的异步I/O！），所以很可能它的执行过程是从上到下一行行进行的
        - 但是，JavaScript引擎在编译这段代码之后可能会发现通过（安全地）重新安排这些语句的顺序有可能提高执行速度
            ```javascript
            var a, b; 
            a = 10; 
            a++; 
            b = 30; 
            b++; 
            console.log( a + b ); // 42

            //// 或是这样
            var a, b; 
            a = 11; 
            b = 31; 
            console.log( a + b ); // 42

            //// 甚至这样
            // 因为a和b不会被再次使用
            // 我们可以inline，从而完全不需要它们！
            console.log( 42 ); // 42 
            ```
            - 前面的所有情况中，JavaScript引擎在编译期间执行的都是安全的优化，最后可见的结果都是一样的
        - 但是这里有一种场景，其中特定的优化是不安全的，因此也是不允许的
            ```javascript
            var a, b; 
            a = 10; 
            b = 30; 
            // 我们需要a和b处于递增之前的状态！
            console.log( a * b ); // 300 
            a = a + 1; 
            b = b + 1; 
            console.log( a + b ); // 42 
            ```
        - 还有其他一些例子，其中编译器重新排序会产生可见的副作用（因此必须禁止），比如会产生副作用的函数调用（特别是`getter`函数），或ES6代理对象
            ```javascript
            function foo() { 
                console.log( b ); 
                return 1; 
            } 
            var a, b, c;
            // ES5.1 getter字面量语法
            c = { 
                get bar() { 
                    console.log( a ); 
                    return 1; 
                } 
            }; 
            a = 10; 
            b = 30; 
            a += foo(); // 30 
            b += c.bar; // 11 
            console.log( a + b ); // 42 
            ```
            - 如果不是因为代码片段中的语句`console.log(..)`（只是作为一种方便的形式说明可见的副作用），JavaScript引擎如果愿意的话，本来可以自由地把代码重新排序如下
                ```javascript
                // ... 
                a = 10 + foo(); 
                b = 30 + c.bar; 
                // ...
                ```
            - 尽管JavaScript语义让我们不会见到编译器语句重排序可能导致的噩梦，**但是代码编写的方式（从上到下的模式）和编译后执行的方式之间的联系非常脆弱**

        