<!--
 * @Author: jiaminghui
 * @Date: 2022-12-04 21:13:00
 * @LastEditTime: 2022-12-04 21:59:49
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\作用域和闭包\闭包.md
 * @Description: 
-->
# JavaScript的作用域闭包
- 闭包：闭包是基于词法作用域书写代码时所产生的自然结果，闭包的创建和使用在你的代码中随处可见
- 缺少的是根据自己的意愿来识别、拥抱和影响闭包的思维环境

## 闭包

### 理解闭包
1.  闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包。**即使函数是在当前词法作用域之外执行**
    ```javascript
    function foo() {
        var a = 2;
        function bar() { 
            console.log( a );
        }
        return bar;
    }
    var baz = foo();
    baz(); // 2 —— 朋友，这就是闭包的效果。
    ```
    - 上述代码中，`bar`函数在自己定义的词法作用域之外被执行
    - 看似`foo()`执行后，内部的作用域会被垃圾回收器释放
    - 但是由于`bar`在使用`foo`内部的作用域（闭包），使得没有被回收，以供`bar`在之后任何时间进行引用
    - `bar()`依然持有对该作用域的引用，而这个引用就叫作闭包。闭包使得函数可以继续访问定义时的词法作用域
2.  闭包的不同表现形式：
    1.直接传递函数
    ```javascript
    function foo() {
        var a = 2;
        function baz() {
            console.log( a ); // 2
        }
        bar( baz );
    }
    function bar(fn) {
        fn(); // 妈妈快看呀，这就是闭包！
    }
    ```
    2.间接传递函数
    ```javascript
    var fn;
    function foo() {
        var a = 2;
        function baz() {
            console.log( a );
        }
        fn = baz; // 将 baz 分配给全局变量
    }
    function bar() {
        fn(); // 妈妈快看呀，这就是闭包！
    }
    foo();
    bar(); // 2
    ```
    - 无论通过何种手段将**内部函数传递到所在的词法作用域以外**，它都会持有对原始定义作用域的引用，**无论在何处执行这个函数都会使用闭包**

3.  实际应用中的闭包
    1.`setTimeout`
    ```javascript
    function wait(message) {
        setTimeout( function timer() {
        console.log( message );
        }, 1000 );
    }

    wait( "Hello, closure!" );
    ```
    - 内部函数`timer`具有覆盖`wait`函数作用域的闭包，保有着对message的引用
    - 当引擎在经过1000ms之后，会调用这个内部函数，在此过程中`timer`保持它原来词法作用域（闭包）的完整

    2.事件监听（jQuery）
    ```javascript
    function setupBot(name, selector) {
        $( selector ).click( function activator() {
            console.log( "Activating: " + name );
        } );
    }
    setupBot( "Closure Bot 1", "#bot_1" );
    setupBot( "Closure Bot 2", "#bot_2" );
    ```
    - 监听的内部函数`activator`也存在闭包，保持着对`name`的引用，当事件发生并监听到之后，调用事件函数会正常输出

    **在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中只要使用了回调函数，实际上就是在使用闭包**
4.  IIFE并不是严格意义上的闭包例子
    - 因为IIFE在定义时所在的作用域中执行，并不能在定义的作用域之外执行
    - 变量仅需要通过普通的词法作用域查找即可被找到
    - 尽管IIFE本身并不是观察闭包的恰当例子，**但它的确创建了闭包**，也是最常用来创建可以被封闭起来的闭包的工具

## 循环和闭包

### 