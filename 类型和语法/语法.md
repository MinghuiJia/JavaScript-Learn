<!--
 * @Author: jiaminghui
 * @Date: 2023-01-07 14:57:07
 * @LastEditTime: 2023-01-07 17:22:58
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\类型和语法\语法.md
 * @Description: 
-->
# 语法的学习

## 语句和表达式
1.  开发人员常常将“语句”（statement）和“表达式”（expression）混为一谈，但这里我们要将二者区别开来
2.  “句子”（sentence）是完整表达某个意思的一组词，由一个或多个“短语”（phrase）组成，它们之间由标点符号或连接词（and 和 or 等）连接起来。短语可以由更小的短语组成
3.  JavaScript的语法也是如此。语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。语句是由表达式和运算符组成的
4.  JavaScript中表达式可以返回一个结果值
    ```javascript
    var a = 3 * 6;
    var b = a;
    b;
    ```
    - `3 * 6`是一个表达式（结果为18）。第二行的a也是一个表达式，第三行的b也是。表达式a和b的结果值都是18
    - 这三行代码都是包含表达式的语句。`var a = 3 * 6`和`var b = a`称为“声明语句”，因为它们声明了变量（还可以为其赋值）。`a = 3 * 6`和`b = a`（不带var）叫作“赋值表达式”
    - 第三行代码中只有一个表达式b，同时它也是一个语句（虽然没有太大意义）。这样的情况通常叫作“表达式语句”（expression statement）
5.  很多人不知道，语句都有一个结果值（statement completion value，undefined也算），获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值
    - 以赋值表达式`b = a`为例，其结果值是赋给b的值（18），但规范定义var的结果值是undefined。如果在控制台中输入`var a = 42`会得到结果值 undefined，而非42
6.  代码块`{ .. }`语句的结果值是其最后一个语句/表达式的结果
    ```javascript
    var b;
    if (true) {
        b = 4 + 38;
    }
    ```
    - 在控制台/REPL中输入以上代码应该会显示42，即最后一个语句/表达式`b = 4 + 38`的结果值
7.  语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前不行）
    ```javascript
    var a, b;
    a = if (true) {
        b = 4 + 38;
    };
    ```
    - 上面这样的代码无法运行
8.  获得语句的结果值的方法（`eval(..)`），但**切勿在实际开发中这样操作**
    ```javascript
    var a, b;
    a = eval( "if (true) { b = 4 + 38; }" );
    a; // 42
    ```
9.  ES7规范有一项“do表达式”也可以获取语句的结果值
    ```javascript
    var a, b;
    a = do {
        if (true) {
            b = 4 + 38; 
        }
    };
    a; // 42
    ```
    - `do { .. }`表达式执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量a
    - 其目的是将语句当作表达式来处理（语句中可以包含其他语句），从而不需要将语句封装为函数再调用return来返回值
10. 表达式的副作用
    - 大部分表达式没有副作用
        ```javascript
        var a = 2;
        var b = a + 3;
        ```
        - 表达式`a + 3`本身没有副作用（比如改变a的值）。它的结果值为5，通过`b = a + 3`赋值给变量b
    - 最常见的有副作用（也可能没有）的表达式是函数调用
        ```javascript
        function foo() {
            a = a + 1;
        }
        var a = 1;
        foo(); // 结果值：undefined。副作用：a的值被改变
        ```
    - 运算符`++`和递减运算符`--`
        ```javascript
        var a = 42;
        var b = a++;
        a; // 43
        b; // 42
        ```
        - `a++`首先返回变量a的当前值42（再将该值赋给b），然后将a的值加1
        - `++`在前面时，如`++a`，它的副作用（将a递增）产生在表达式返回结果值之前，而`a++`的副作用则产生在之后
    - 可以使用`,`语句系列逗号运算符将多个独立的表达式语句串联成一个语句，使得产生副作用之后再执行
        ```javascript
        var a = 42, b;
        b = ( a++, a );
        a; // 43
        b; // 43
        ```
        - 由于运算符优先级的关系，`a++, a`需要放到`( .. )`中
        - `a++, a`中第二个表达式a在`a++`之后执行，结果为43，并被赋值给b
    - delete运算符用来删除对象中的属性和数组中的单元。它通常以单独一个语句的形式出现
        ```javascript
        var obj = {
            a: 42
        };
        obj.a; // 42
        delete obj.a; // true
        obj.a; // undefined
        ```
        - 如果操作成功，delete返回true，否则返回false。其副作用是属性被从对象中删除（或者单元从array中删除）
        - 操作成功是指对于那些不存在或者存在且可配置（configurable）的属性，delete返回true，否则返回false或者报错
    - =赋值运算符的副作用
        - 下述代码，`a = 42`中的=运算符看起来没有副作用，实际上它的结果值是42，它的副作用是将42赋值给a
            ```javascript
            var a;
            a = 42; // 42
            a; // 42
            ```
        - 组合赋值运算符，如`+=`和`-=`等也是如此。例如，`a = b += 2`首先执行`b += 2`（即`b = b + 2`），然后结果再被赋值给a
        - 多个赋值语句串联时（链式赋值，chained assignment），赋值表达式（和语句）的结果值就能派上用场
            ```javascript
            var a, b, c;
            a = b = c = 42;
            ```
            - 这里`c = 42`的结果值为42（副作用是将c赋值42），然后`b = 42`的结果值为42，最后是`a = 42`
        - 链式赋值常常被误用，例如`var a = b = 42`，如果变量b没有在作用域中`var b`这样声明过，则链式赋值不会对变量b进行声明。在严格模式中这样会产生错误，或者会无意中创建一个全局变量
        - 利用=赋值运算符，将两个if语句合二为一
            ```javascript
            function vowels(str) {
                var matches;
                if (str) {
                    // 提取所有元音字母
                    matches = str.match( /[aeiou]/g );
                    if (matches) {
                        return matches;
                    } 
                }
            }
            vowels( "Hello World" ); // ["e","o","o"]

            //// 使用=赋值将两个if合二为一
            function vowels(str) {
                var matches;
                // 提取所有元音字母
                if (str && (matches = str.match( /[aeiou]/g ))) {
                    return matches;
                }
            }
            vowels( "Hello World" ); // ["e","o","o"]
            ```
            - 将`matches = str.match..`放到`( .. )`中是必要的
11. 上下文规则
    - 大括号，下面两种情况会用到大括号`{ .. }`
        ```javascript
        // 假定函数bar()已经定义
        var a = {
            foo: bar()
        };
        ```
        - `{ .. }`被赋值给a，因而它是一个对象常量，用大括号定义对象常量
    - 标签
        ```javascript
        // 假定函数bar()已经定义
        {
            foo: bar()
        }
        ```
        - `{ .. }`在这里只是一个普通的代码块，特别是和let（块作用域声明）在一起时非常有用。`{ .. }`和`for/while`循环以及if条件语句中代码块的作用基本相同
        - `foo: bar()`叫作“标签语句”，foo是语句`bar()`的标签（后面没有`;`），结合continue与break能够像goto那样进行跳转
            ```javascript
            // 标签为foo的循环
            foo: for (var i=0; i<4; i++) {
                for (var j=0; j<4; j++) {
                    // 如果j和i相等，继续外层循环
                    if (j == i) {
                        // 跳转到foo的下一个循环
                        continue foo;
                    }
                    // 跳过奇数结果
                    if ((j * i) % 2 == 1) {
                        // 继续内层循环（没有标签的）
                        continue; 
                    }
                    console.log( i, j );
                }
            }
            // 1 0
            // 2 0
            // 2 1
            // 3 0
            // 3 2
            ```
            - `contine foo`并不是指“跳转到标签foo所在位置继续执行”，而是“执行foo循环的下一轮循环”。所以这里的foo并非goto
            - 上例中continue跳过了循环`2 1`、`3 1`，`continue foo`跳过了循环`0 0`、`1 1`和`2 2` `3 3`
        - 带标签的循环跳转一个更大的用处在于，和`break __`一起使用可以实现从内层循环跳转到外层循环。没有它们的话实现起来有时会非常麻烦
            ```javascript
            // 标签为foo的循环
            foo: for (var i=0; i<4; i++) {
                for (var j=0; j<4; j++) {
                    if ((i * j) >= 3) {
                        console.log( "stopping!", i, j );
                        break foo; 
                    }
                    console.log( i, j );
                }
            }
            // 0 0
            // 0 1
            // 0 2
            // 0 3
            // 1 0
            // 1 1
            // 1 2
            // 停止！ 1 3
            ```
            - `break foo`指“跳出标签foo所在的循环/代码块，继续执行后面的代码”
        - 标签也能用于非循环代码块，但只有break才可以
            ```javascript
            // 标签为bar的代码块
            function foo() {
                bar: {
                    console.log( "Hello" );
                    break bar;
                    console.log( "never runs" );
                }
                console.log( "World" );
            }
            foo();
            // Hello
            // World
            ```
            - 带标签的循环/代码块十分少见，也不建议使用
    - JSON的确是JavaScript语法的一个子集，但是JSON本身并不是合法的JavaScript语法。如果通过`<script src=..>`标签加载JavaScript文件，其中只包含JSON数据（比如某个API返回的结果），那它就会被当作合法的JavaScript代码来解析，只不过其内容无法被程序代码访问到。**JSON-P（将 JSON数据封装为函数调用，比如`foo({"a":42})`）通过将JSON数据传递给函数来实现对其的访问**
    - `{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生错误，因为它会被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有这个问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的对象常量。JSON-P能将JSON转换为合法的JavaScript语法
    - 代码块
        ```javascript
        [] + {}; // "[object Object]"
        {} + []; // 0
        ```
        - 第一行代码中，{}出现在+运算符表达式中，因此它被当作一个值（空对象）来处理，[]会被强制类型转换为""，而{}会被强制类型转换为"[object Object]"
        - 第二行代码中，{}被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后`+ []`将[]显式强制类型转换为0
    - 对象的解构
        -  ES6开始，`{ .. }`也可用于“解构赋值”，特别是对象的解构
            ```javascript
            function getData() {
                // ..
                return {
                    a: 42,
                    b: "foo" 
                };
            }
            var { a, b } = getData();
            console.log( a, b ); // 42 "foo"
            ```
            - `{ a , b } = ..`就是ES6中的解构赋值，相当于`var res = getData(); var a = res.a; var b = res.b;`
        - `{ .. }`还可以用作函数命名参数（named function argument）的对象解构，方便隐式地用对象属性赋值
            ```javascript
            function foo({ a, b, c }) {
                // 不再需要这样:
                // var a = obj.a, b = obj.b, c = obj.c
                console.log( a, b, c );
            }
            foo( {
                c: [1,2,3],
                a: 42,
                b: "foo"
            } ); // 42 "foo" [1, 2, 3]
            ```
    - `else if`和可选代码块
        - 很多人误以为JavaScript中有`else if`，因为我们可以这样来写代码
            ```javascript
            if (a) { 
                // ..
            }
            else if (b) {
                // .. 
            }
            else { 
                // ..
            }
            ```
            - 事实上JavaScript没有`else if`，但if和else只包含单条语句的时候可以省略代码块的`if (a) doSomething( a );`
        - `else if`实际上是跟在else后面的一个单独的语句，所以带不带`{ }`都可以
            ```javascript
            if (a) { 
                // ..
            } 
            else {
                if (b) { 
                    // ..
                } 
                else {
                    // .. 
                }
            }
            ```



