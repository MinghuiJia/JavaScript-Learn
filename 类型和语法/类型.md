<!--
 * @Author: jiaminghui
 * @Date: 2022-12-31 15:34:02
 * @LastEditTime: 2023-01-03 22:58:21
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\类型和语法\类型.md
 * @Description: 
-->
# JavaScript类型的学习

## 类型
1.  大多数开发者认为，像JavaScript这样的动态语言是没有类型（type）的，但是ES5规范中规定**运算法则所操纵的值均有相应的类型**。在ECMAScript中类型包括：
    - Number
    - String
    - Boolean
    - Null
    - Undefined
    - Object
    - Symbol（ES6中新增的）
**除了对象类型外，其他的统称为基本类型**
2.  有人认为JavaScript中的“类型”应该称为“标签”（tag）或者“子类型”（subtype），而JavaScript中认为自己有类型，并把类型定义为：对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。针对42和"42"，开发人员与引擎采取不同的处理方式，对数字42进行数学运算，而对字符串"42"进行字符串操作，比如输出到页面。因此它们是不同的类型
3.  深入了解类型，有助于**正确合理地进行类型转换（强制类型转换）**
4.  我们可以使用`typeof`运算符来查看值的类型，它返回的是类型的字符串值
    ```javascript
    typeof undefined === "undefined"; // true
    typeof true === "boolean"; // true
    typeof 42 === "number"; // true
    typeof "42" === "string"; // true
    typeof { life: 42 } === "object"; // true
    // ES6中新加入的类型
    typeof Symbol() === "symbol"; // true

    typeof null === "object"; // true
    ```
    - 上述返回的类型字符串，除了null之外都有同名的字符串值与之对应，为了检查null值的类型需要使用复合条件
        ```javascript
        var a = null;
        (!a && typeof a === "object"); // true
        ```
    - function（函数）不是JavaScript的内置类型，而是object的一个“子类型”。函数是“可调用对象”，它有一个内部属性`[[Call]]`，该属性使其可以被调用
        ```javascript
        typeof function a(){ /* .. */ } === "function"; // true
        ```
    - 函数不仅是对象，还可以拥有属性，函数对象的length属性是其声明的参数的个数
        ```javascript
        function a(b,c) {
            /* .. */
        }
        a.length; // 2
        ```
    - JavaScript支持数组，数组也是Object的一个“子类型”，数组的元素按数字顺序来进行索引，其length属性是元素的个数
        ```javascript
        typeof [1,2,3] === "object"; // true
        ```
5.  JavaScript中的变量是没有类型的，**只有值才有**，变量可以随时持有任何类型的值。语言引擎不要求变量总是持有与其初始值同类型的值
    - 在对变量执行`typeof`操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为JavaScript中的变量没有类型
        ```javascript
        var a = 42;
        typeof a; // "number"
        a = true;
        typeof a; // "boolean"
        ```
    - `typeof`运算符总是会返回一个字符串
        ```javascript
        typeof typeof 42; // "string"
        ```
    - 变量在未持有值的时候为undefined。此时`typeof`返回"undefined"
        ```javascript
        var a;
        typeof a; // "undefined"
        var b = 42;
        var c;
        // later 
        b = c;
        typeof b; // "undefined"
        typeof c; // "undefined"
        ```
    - 在JavaScript中undefined不等同于undeclared（未声明），已在作用域中声明但还没有赋值的变量，是undefined的；还没有在作用域中声明过的变量，是undeclared的
        ```javascript
        var a;
        a; // undefined
        b; // ReferenceError: b is not defined "b is not found" 或者 "b is not declared"会更准确
        ```
        - 此外，使用`typeof`并不能区分变量是undeclared还是undefined
            ```javascript
            var a;
            typeof a; // "undefined"
            typeof b; // "undefined"
            ```
            - 这是因为`typeof`有一个特殊的安全防范机制
6.  JavaScript中typeof Undeclared的用处
    - 在程序中使用全局变量DEBUG作为“调试模式”的开关。在输出调试信息到控制台之前，我们会检查DEBUG变量是否已被声明。顶层的全局变量声明`var DEBUG = true`只在debug.js文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环境中不予加载
    - 如何在程序中检查全局变量DEBUG才不会出现ReferenceError错误，这时`typeof`的安全防范机制就成了我们的好帮手
        ```javascript
        // 这样会抛出错误
        if (DEBUG) {
            console.log( "Debugging is starting" );
        }
        // 这样是安全的
        if (typeof DEBUG !== "undefined") {
            console.log( "Debugging is starting" );
        }
        ```
    - 这不仅对用户定义的变量（比如DEBUG）有用，对内建的API也有帮助
        ```javascript
        if (typeof atob === "undefined") {
            atob = function() { /*..*/ };
        }
        ```
    - 另一种不用通过`typeof`的安全防范机制的方法，就是检查所有全局变量是否是全局对象的属性，浏览器中的全局对象是window
        ```javascript
        if (window.DEBUG) {
            // ..
        }
        if (!window.atob) {
            // ..
        }
        ```
        - 与undeclared变量不同，访问不存在的对象属性（甚至是在全局对象window上）不会产生ReferenceError错误，而是会返回undefined值
        - 另外当代码需要运行在多种JavaScript环境中时（不仅仅是浏览器，还有服务器端，如 node.js 等）此时全局对象并非总是window，检查全局变量是否是全局对象的属性就会给代码编写造成问题
    - typeof的安全防范机制对于非全局变量也很管用，如果想让别人在他们的程序或模块中复制粘贴你的代码，就需要检查你用到的变量是否已经在宿主程序中定义过
        ```javascript
        // 一个立即执行函数表达式（IIFE，参见《你不知道的JavaScript（上卷）》“作用域和闭包”
        // 部分的3.3.2节）
        (function(){
            function FeatureXYZ() { /*.. my XYZ feature ..*/ }
            // 包含doSomethingCool(..)
            function doSomethingCool() {
                var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
                var val = helper();
                // .. 
            }
            doSomethingCool();
        })();
        ```
        - 其他模块和程序引入`doSomethingCool()`时，`doSomethingCool()`会检查`FeatureXYZ`变量是否已经在宿主程序中定义过；如果是，就用现成的，否则就自己定义
        - 上述代码FeatureXYZ并不是一个全局变量，但我们还是可以使用`typeof`的安全防范机制来做检查，因为这里没有全局对象可用
    - 还有一些人喜欢使用“依赖注入”（dependency injection）设计模式，就是将依赖通过参数显式地传递到函数中
        ```javascript
        function doSomethingCool(FeatureXYZ) {
            var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
            var val = helper();
            // ..
        }
        ```
## 值
1.  数组在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组
    ```javascript
    var a = [ 1, "2", [3] ];
    a.length; // 3
    a[0] === 1; // true
    a[2][0] === 3; // true
    ```
    - 对数组声明后即可向其中加入值，不需要预先设定大小
        ```javascript
        var a = [ ];
        a.length; // 0
        a[0] = 1;
        a[1] = "2";
        a[2] = [ 3 ];
        a.length; // 3
        ```
        - 使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化
    - 在创建“稀疏”数组（sparse array，即含有空白或空缺单元的数组）时要特别注意
        ```javascript
        var a = [ ];
        a[0] = 1;
        // 此处没有设置a[1]单元
        a[2] = [ 3 ];
        a[1]; // undefined
        a.length; // 3
        ```
        - 上面的代码可以正常运行，但其中的“空白单元”（empty slot）为undefined。a[1]的值为undefined，但这与将其显式赋值为undefined（`a[1] = undefined`）还是有所区别
    - 数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）
        ```javascript
        var a = [ ];
        a[0] = 1;
        a["foobar"] = 2;
        a.length; // 1
        a["foobar"]; // 2
        a.foobar; // 2
        ```
        - 如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理
            ```javascript
            var a = [ ];
            a["13"] = 42;
            a.length; // 14
            ```
        
        **注意：在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值，用数组来存放数字索引值**
2.  类数组：有时需要将类数组（一组通过数字索引的值）转换为真正的数组，这一般通过数组工具函数（如`indexOf(..)`、`concat(..)`、`forEach(..)`等）来实现
    - 一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）
    - 工具函数`slice(..)`经常被用于这类转换
        ```javascript
        function foo() {
            var arr = Array.prototype.slice.call( arguments );
            arr.push( "bam" );
            console.log( arr );
        }
        foo( "bar", "baz" ); // ["bar","baz","bam"]
        ```
        - 如上所示，`slice()`返回参数列表（上例中是一个类数组）的一个数组复本
        - 用ES6中的内置工具函数`Array.from(..)`也能实现同样的功能`var arr = Array.from( arguments );`
3.  字符串
    - 字符串经常被当成字符数组，但JavaScript中的字符串和字符数组并不是一回事，最多只是看上去相似而已
    - 字符串与字符数组都有`length`属性以及`indexOf(..)`（从ES5开始数组支持此方法）和`concat(..)`方法
        ```javascript
        var a = "foo";
        var b = ["f","o","o"];
        a.length; // 3
        b.length; // 3
        a.indexOf( "o" ); // 1
        b.indexOf( "o" ); // 1
        var c = a.concat( "bar" ); // "foobar"
        var d = b.concat( ["b","a","r"] ); // ["f","o","o","b","a","r"]
        a === c; // false
        b === d; // false
        a; // "foo" 
        b; // ["f","o","o"]
        ```
    - 但本质上字符串与字符数组不能等价
        ```javascript
        a[1] = "O";
        b[1] = "O";
        a; // "foo"
        b; // ["f","O","o"]
        ```
        - JavaScript中字符串是不可变的，而数组是可变的。并且`a[1]`在JavaScript中并非总是合法语法，在老版本的IE中就不被允许。正确的方法应该是`a.charAt(1)`
    - 字符串不可变是指字符串的成员函数不会改变其原始值，而是**创建并返回一个新的字符串**。而数组的成员函数都是在其原始值上进行操作
        ```javascript
        c = a.toUpperCase();    // 字符串的成员函数toUpperCaae会返回一个新的字符串
        a === c; // false
        a; // "foo"
        c; // "FOO"
        b.push( "!" );
        b; // ["f","O","o","!"]
        ```
    - 许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串
        ```javascript
        a.join; // undefined
        a.map; // undefined
        var c = Array.prototype.join.call( a, "-" );
        var d = Array.prototype.map.call( a, function(v){
            return v.toUpperCase() + ".";
        } ).join( "" );
        c; // "f-o-o"
        d; // "F.O.O."
        ```
    - 此外重要的一点区别是**字符串反转（JavaScript 面试常见问题）**。数组有一个字符串没有的可变更成员函数`reverse()`
        ```javascript
        a.reverse; // undefined
        b.reverse(); // ["!","o","O","f"]
        b; // ["f","O","o","!"]
        ```
        - 可惜我们无法“借用”数组的可变更成员函数，因为字符串是不可变的。`Array.prototype.reverse.call( a );`返回的仍然是字符串"foo"的一个封装对象
        - 一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串
            ```javascript
            var c = a
                // 将a的值转换为字符数组
                .split( "" )
                // 将数组中的字符进行倒转
                .reverse()
                // 将数组中的字符拼接回字符串
                .join( "" );
            c; // "oof"
            ```
            - 上述方法对于包含复杂字符（Unicode，如星号、多字节字符等）的字符串并不适用。需要功能更加完备、能够处理Unicode的工具库来完成

        **如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在字符串和数组之间来回折腾。可以在需要时使用`join("")`将字符数组转换为字符串**
4.  数字
    - JavaScript只有一种数值类型：number（数字），包括“整数”和带小数的十进制数
    - JavaScript中的“整数”就是没有小数的十进制数。所以42.0即等同于“整数”42
    - 数字的语法
        - JavaScript中的数字常量一般用十进制表示
            ```javascript
            var a = 42;
            var b = 42.3;
            ```
        - 数字前面的0可以省略
            ```javascript
            var a = 0.42;
            var b = .42;
            ```
        - 小数点后小数部分最后面的0也可以省略
            ```javascript
            var a = 42.0;
            var b = 42.;
            ```
            - 42.这种写法没问题，只是不常见，但从代码的可读性考虑，不建议这样写
        - 默认情况下大部分数字都以十进制显示，小数部分最后面的0被省略
            ```javascript
            var a = 42.300;
            var b = 42.0;
            a; // 42.3
            b; // 42
            ```
        - 特别大和特别小的数字默认用指数格式显示，与`toExponential()`函数的输出结果相同
            ```javascript
            var a = 5E10;
            a; // 50000000000
            a.toExponential(); // "5e+10"
            var b = a * a;
            b; // 2.5e+21
            var c = 1 / a;
            c; // 2e-11
            ```
        - 由于数字值可以使用Number对象进行封装，因此数字值可以调用Number.prototype中的方法。例如，`tofixed(..)`方法可指定小数部分的显示位数
            ```javascript
            var a = 42.59;
            a.toFixed( 0 ); // "43"
            a.toFixed( 1 ); // "42.6"
            a.toFixed( 2 ); // "42.59"
            a.toFixed( 3 ); // "42.590"
            a.toFixed( 4 ); // "42.5900"
            ```
            - 上例中的输出结果实际上是**给定数字的字符串形式**，如果指定的小数部分的显示位数多于实际位数就用0补齐
        - `toPrecision(..)`方法用来指定有效数位的显示位数
            ```javascript
            var a = 42.59;
            a.toPrecision( 1 ); // "4e+1"
            a.toPrecision( 2 ); // "43"
            a.toPrecision( 3 ); // "42.6"
            a.toPrecision( 4 ); // "42.59"
            a.toPrecision( 5 ); // "42.590"
            a.toPrecision( 6 ); // "42.5900"
            ```
        - 上面的方法不仅适用于数字变量，也适用于数字常量。不过对于`.`运算符它是一个有效的数字字符，**会被优先识别为数字常量的一部分**，然后才是对象属性访问运算符
            ```javascript
            // 无效语法：
            42.toFixed( 3 ); // SyntaxError
            // 下面的语法都有效：
            (42).toFixed( 3 ); // "42.000"
            0.42.toFixed( 3 ); // "0.420"
            42..toFixed( 3 ); // "42.000"
            ```
            - `42.tofixed(3)`是无效语法，因为`.`被视为常量`42.`的一部分
            - `42..tofixed(3)`则没有问题，因为第一个`.`被视为number的一部分，第二个`.`是属性访问运算符
            - `42 .toFixed(3); // "42.000"`也是有效的（请注意其中的空格），对数字常量而言，这样的语法很容易引起误会，不建议使用
        - 我们还可以用指数形式来表示较大的数字
            ```javascript
            var onethousand = 1E3; // 即 1 * 10^3
            var onemilliononehundredthousand = 1.1E6; // 即 1.1 * 10^6
            ```
        - 数字常量还可以用其他格式来表示，如二进制、八进制和十六进制
            ```javascript
            0xf3; // 243的十六进制
            0Xf3; // 同上
            0363; // 243的八进制
            ```
            - 从ES6开始，严格模式（strict mode）不再支持0363八进制格式，考虑到将来的兼容性，最好不要再使用
        - ES6支持以下新格式
            ```javascript
            0o363; // 243的八进制
            0O363; // 同上
            0b11110011; // 243的二进制
            0B11110011; // 同上
            ```
    - 二进制浮点数最大的问题是会出现如下情况
        ```javascript
        0.1 + 0.2 === 0.3; // false
        ```
        - 二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断结果为false
    - 在处理带有小数的数字时需要特别注意，通常会设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)
    - 从ES6开始，该值定义在Number.EPSILON中，也可以为ES6之前的版本写polyfill
        ```javascript
        if (!Number.EPSILON) {
            Number.EPSILON = Math.pow(2,-52);
        }
        ```
    - 使用Number.EPSILON来比较两个数字是否相等（在指定的误差范围内）
        ```javascript
        function numbersCloseEnoughToEqual(n1,n2) {
            return Math.abs( n1 - n2 ) < Number.EPSILON;
        }
        var a = 0.1 + 0.2;
        var b = 0.3;
        numbersCloseEnoughToEqual( a, b ); // true
        numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false
        ```
    - 能够呈现的最大浮点数大约是1.798e+308（这是一个相当大的数字），它定义在Number.MAX_VALUE中，最小浮点数定义在Number.MIN_VALUE中，大约是5e-324，它不是负数，但无限接近于0
    - 能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在ES6中被定义为Number.MIN_SAFE_INTEGER
    - 有时JavaScript程序需要处理一些比较大的数字，如数据库中的64位ID等。由于JavaScript的数字类型无法精确呈现64位数值，所以必须将它们保存（转换）为字符串
    - 整数检测：可以使用ES6中的`Number.isInteger(..)`方法
        ```javascript
        Number.isInteger( 42 ); // true
        Number.isInteger( 42.000 ); // true
        Number.isInteger( 42.3 ); // false
        ```
        - 也可以为ES6之前的版本polyfill`Number.isInteger(..)`方法
            ```javascript
            if (!Number.isInteger) {
                Number.isInteger = function(num) {
                    return typeof num == "number" && num % 1 == 0;
                };
            }
            ```
    - 检测一个值是否是安全的整数，可以使用ES6中的`Number.isSafeInteger(..)`方法
        ```javascript
        Number.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true
        Number.isSafeInteger( Math.pow( 2, 53 ) ); // false
        Number.isSafeInteger( Math.pow( 2, 53 ) - 1 ); // true
        ```
        - 可以为ES6之前的版本polyfill`Number.isSafeInteger(..)`方法
            ```javascript
            if (!Number.isSafeInteger) {
                Number.isSafeInteger = function(num) {
                    return Number.isInteger( num ) &&
                        Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
                }; 
            }
            ```
    - 32位有符号整数。虽然整数最大能够达到53位，但是有些数字操作（如数位操作）只适用于32位数字，所以这些操作中数字的安全范围就要小很多，变成从`Math.pow(-2,31)`（-2147483648，约－21亿）到`Math.pow(2,31) - 1`（2147483647，约21 亿）。**因为是有符号的32位，第一位要用于设置正负，所以才是2的31次方；-1的原因是位数是从0开始的，31位都是1等价于32位是1其余位是0的十进制数再减一**
        - `a | 0`可以将变量a中的数值转换为32位有符号整数，因为数位运算符`|`只适用于32位整数。因此与0进行操作即可截取a中的32位数位
        - 某些特殊的值并不是32位安全范围的，如NaN和Infinity，此时会对它们执行虚拟操作（abstract operation）ToInt32，以便转换为符合数位运算符要求的+0值
5.  特殊的数值
    - JavaScript数据类型中有几个特殊的值需要开发人员特别注意和小心使用
    - 不是值的值
        - undefined类型只有一个值，即undefined。null类型也只有一个值，即null。它们的名称既是类型也是值
        - undefined和null常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别
            - null指空值（empty value）或指曾赋过值，但是目前没有值
            - undefined指没有值（missing value）或指从未赋值
            - null是一个特殊关键字，不是标识符，我们**不能将其当作变量来使用和赋值**，而undefined却是一个标识符，可以被当作变量来使用和赋值
    - 在非严格模式下，我们可以为全局标识符undefined赋值
        ```javascript
        function foo() {
            undefined = 2; // 非常糟糕的做法！
        }
        foo();
        function foo() {
            "use strict";
            undefined = 2; // TypeError!
        }
        foo();
        ```
    - 在非严格和严格两种模式下，我们可以声明一个名为undefined的局部变量
        ```javascript
        function foo() {
            "use strict";
            var undefined = 2;
            console.log( undefined ); // 2
        }
        foo();
        ```
    - 但是需要注意，上述对undefined进行赋值和重新声明的做法不可取
    - 通过void运算符即可得到undefined内置标识符的值
        ```javascript
        var a = 42;
        console.log( void a, a ); // undefined 42
        ```
        - 表达式`void ___`没有返回值，因此返回结果是undefined，void并不改变表达式的结果，只是让表达式不返回值
        - 按照惯例我们用`void 0`来获得undefined，`void 0`、`void 1`和undefined之间并没有实质上的区别
        - void运算符在其他地方可以不让表达式返回任何结果（即使其有副作用）
            ```javascript
            function doSomething() {
                // 注： APP.ready 由程序自己定义
                if (!APP.ready) {
                    // 稍后再试
                    return void setTimeout( doSomething,100 );
                }
                var result;
                // 其他
                return result;
            }
            // 现在可以了吗？
            if (doSomething()) {
                // 立即执行下一个任务
            }
            ```
            - 这里`setTimeout(..)`函数返回一个数值，但是为了确保if语句不产生误报（false positive），我们要void掉它返回undefined
            - 另一种更常用的方式是分开`setTimout`与`return`
            ```javascript
            if (!APP.ready) {
                // 稍后再试
                setTimeout( doSomething,100 );
                return;
            }
            ```
    - 特殊的数字
        - 不是数字的数字（如果数学运算的操作数不是数字类型就无法返回一个有效的数字，这种情况下返回值为NaN）
        - NaN意指“不是一个数字”（not a number）。它理解为“无效数值”“失败数值”或者“坏数值”可能更准确些
            ```javascript
            var a = 2 / "foo"; // NaN
            typeof a === "number"; // true
            ```
            - “不是数字的数字”仍然是数字类型
        - NaN是一个“警戒值”，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”
        - 如果要检查变量的值是否为NaN，直接和NaN进行比较不行（不像null或undefined可以直接进行比较）
            ```javascript
            var a = 2 / "foo";
            a == NaN; // false
            a === NaN; // false
            ```
        - NaN是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即`x === x`不成立）的值，而`NaN != NaN`为true
        - 判断NaN的方法，使用`isNaN(..)`
            ```javascript
            var a = 2 / "foo";
            isNaN( a ); // true
            ```
            - `isNaN(..)`是一个内建的全局工具函数
        - NaN方法存在缺陷，它检查参数是否不是NaN，也不是数字
            ```javascript
            var a = 2 / "foo";
            var b = "foo";
            a; // NaN
            b; "foo"
            window.isNaN( a ); // true
            window.isNaN( b ); // true——晕！
            ```
            - 很明显"foo"不是一个数字，但是它也不是NaN
        - ES6中使用工具函数`Number.isNaN(..)`
            ```javascript
            if (!Number.isNaN) {
                Number.isNaN = function(n) {
                    return (
                        typeof n === "number" &&
                        window.isNaN( n )
                    ); 
                };
            }
            var a = 2 / "foo";
            var b = "foo";
            Number.isNaN( a ); // true
            Number.isNaN( b ); // false——好！
            ```
        - 另一个判断NaN的方法是利用NaN的非自反性，是JavaScript中唯一一个不等于自身的值
            ```javascript
            if (!Number.isNaN) {
                Number.isNaN = function(n) {
                    return n !== n;
                };
            }
            ```
        综上我们应该尽量使用`Number.isNaN(..)`这样可靠的方法，无论是系统内置还是polyfill，而不能使用`isNaN(..)`
    - 无穷数
        ```javascript
        var a = 1 / 0; // Infinity
        var b = -1 / 0; // -Infinity
        ```
        - 在JavaScript中，除以0结果为Infinity（即`Number.POSITIVE_INfiNITY`），-Infinity（即`Number.NEGATIVE_INfiNITY`）
        - JavaScript使用有限数字表示法运算结果有可能溢出，此时结果为Infinity或者-Infinity
            ```javascript
            var a = Number.MAX_VALUE; // 1.7976931348623157e+308
            a + a; // Infinity
            a + Math.pow( 2, 970 ); // Infinity
            a + Math.pow( 2, 969 ); // 1.7976931348623157e+308
            ```
            - 规范规定，如果数学运算（如加法）的结果超出处理范围，采取就近取整模式来决定最后的结果
            - 相对于Infinity，`Number.MAX_VALUE + Math.pow(2, 969)`与Number.MAX_VALUE更为接近，因此它被向下取整；而`Number.MAX_VALUE + Math.pow(2, 970)`与Infinity更为接近，所以它被向上取整
            - 计算结果一旦溢出为无穷数（infinity）就无法再得到有穷数
            - 注意：在JavaScript中`Infinity/Infinity`是一个未定义操作，结果为NaN，而不是1或者无穷
            - 有穷正数除以Infinity的结果是0
    - 零值
        - JavaScript有一个常规的0和一个-0，-0除了可以用作常量以外，也可以是某些数学运算的返回值
            ```javascript
            var a = 0 / -3; // -0
            var b = 0 * -3; // -0
            ```
        - 加法和减法运算不会得到负零
        - 负零在开发调试控制台中通常显示为-0
        - 对负零进行字符串化会返回"0"
            ```javascript
            var a = 0 / -3;
            // 至少在某些浏览器的控制台中显示是正确的
            a; // -0
            // 但是规范定义的返回结果是这样！
            a.toString(); // "0"
            a + ""; // "0"
            String( a ); // "0"
            // JSON也如此，很奇怪
            JSON.stringify( a ); // "0"
            ```
        - 如果反过来将其从字符串转换为数字，得到的结果是准确的
            ```javascript
            +"-0"; // -0
            Number( "-0" ); // -0
            JSON.parse( "-0" ); // -0
            ```
        - -0的比较操作
            ```javascript
            var a = 0;
            var b = 0 / -3;
            a == b; // true
            -0 == 0; // true
            a === b; // true
            -0 === 0; // true
            0 > -0; // false 
            a > b; // false
            ```
        - 要区分-0和0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理
            ```javascript
            function isNegZero(n) {
                n = Number( n );
                return (n === 0) && (1 / n === -Infinity);
            }
            isNegZero( -0 ); // true
            isNegZero( 0 / -3 ); // true
            isNegZero( 0 ); // false
            ```
        - 出现-0的原因：有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位（sign）用来代表其他信息（比如移动的方向）。如果一个值为0的变量失去了它的符号位，它的方向信息就会丢失
    - 特殊等式
        - ES6中新加入了一个工具方法`Object.is(..)`来判断两个值是否绝对相等，可以解决0与-1；NaN的判断
            ```javascript
            var a = 2 / "foo";
            var b = -3 * 0;
            Object.is( a, NaN ); // true
            Object.is( b, -0 ); // true
            Object.is( b, 0 ); // false
            ```
        - `Object.is(..)`的polyfill
            ```javascript
            if (!Object.is) {
                Object.is = function(v1, v2) {
                    // 判断是否是-0
                    if (v1 === 0 && v2 === 0) {
                        return 1 / v1 === 1 / v2;
                    }
                    // 判断是否是NaN
                    if (v1 !== v1) {
                        return v2 !== v2;
                    }
                    // 其他情况
                    return v1 === v2;
                };
            }
            ```
        - 能使用`==`和`===`时就尽量不要使用`Object.is(..)`，因为前者效率更高、更为通用。`Object.is(..)`主要用来处理那些特殊的相等比较
6.  值和引用
    - JavaScript中没有指针，变量不可能成为指向另一个变量的引用
    - JavaScript引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引用/指向关系
    - JavaScript对值和引用的赋值/传递在语法上没有区别，完全根据值的类型来决定
        ```javascript
        var a = 2;
        var b = a; // b是a的值的一个副本
        b++;
        a; // 2
        b; // 3
        var c = [1,2,3];
        var d = c; // d是[1,2,3]的一个引用
        d.push( 4 );
        c; // [1,2,3,4]
        d; // [1,2,3,4]
        ```
    - 简单值（即标量基本类型值-String、Number、Boolean、Null、Undefined、Symbol，scalar primitive）总是通过值复制的方式来赋值/传递
    - 复合值（compound value）——对象和函数，则总是通过引用复制的方式来赋值/传递
    - 由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向
        ```javascript
        var a = [1,2,3];
        var b = a;
        a; // [1,2,3]
        b; // [1,2,3]
        // 然后
        b = [4,5,6];
        a; // [1,2,3]
        b; // [4,5,6]
        ```
        - 如果想修改a的引用，需要让b指向a的指针，但在JavaScript中不存在这种情况
    - 函数参数是引用类型时，在函数内部获取到的形参是对实参的复本进行赋值
        ```javascript
        function foo(x) {
            x.push( 4 );
            x; // [1,2,3,4]
            // 然后
            x = [4,5,6];
            x.push( 7 );
            x; // [4,5,6,7]
        }
        var a = [1,2,3];
        foo( a );
        a; // 是[1,2,3,4]，不是[4,5,6,7]
        ```
        - 我们向函数传递a的时候，实际是将引用a的一个复本赋值给x，而a仍然指向`[1,2,3]`，在函数中我们可以通过引用x来更改数组的值。但`x = [4,5,6]`并不影响a的指向，所以a仍然指向`[1,2,3,4]`。**不能通过引用x来更改引用a的指向，只能更改a和x共同指向的值**
        - 如果要将a的值变为`[4,5,6,7]`，必须更改x指向的数组，而不是为x赋值一个新的数组
            ```javascript
            function foo(x) {
                x.push( 4 );
                x; // [1,2,3,4]
                // 然后
                x.length = 0; // 清空数组
                x.push( 4, 5, 6, 7 );
                x; // [4,5,6,7]
            }
            var a = [1,2,3];
            foo( a );
            a; // 是[4,5,6,7]，不是[1,2,3,4]
            ```
            - 从上例可以看出，`x.length = 0`和`x.push(4,5,6,7)`并没有创建一个新的数组，而是更改了当前的数组。于是a指向的值变成了`[4,5,6,7]`
    
        **注意：我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定**
        
    - 通过值复制的方式来传递复合值（如数组），就需要为其创建一个复本，这样传递的就不再是原始值。`foo( a.slice() );`，`slice(..)`不带参数会返回当前数组的一个浅复本（浅拷贝只会值复制当前拷贝对象内的基本类型，引用类型的变量均指向同一个引用值）。由于传递给函数的是指向该复本的引用，所以`foo(..)`中的操作不会影响a指向的数组
    - 如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（对象、数组等）中，然后通过引用复制的方式传递
        ```javascript
        function foo(wrapper) {
            wrapper.a = 42;
        }
        var obj = { 
            a: 2
        };
        foo( obj );
        obj.a; // 42
        ```
        - 这里obj是一个封装了标量基本类型值a的封装对象，obj引用的一个复本作为参数`wrapper`被传递到`foo(..)`中，这样我们就可以通过wrapper来访问该对象并更改它的属性
        - 这样看来，如果需要传递指向标量基本类型值（比如2）的引用，就可以将其封装到对应的数字封装对象（Number会创建一个Number类型的对象）中
            ```javascript
            function foo(x) {
                x = x + 1;
                x; // 3 
            }
            var a = 2;
            var b = new Number( a ); // Object(a)也一样
            foo( b );
            console.log( b ); // 是2，不是3
            ```
            - 与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值
            - 原因是**标量基本类型值是不可更改的（字符串和布尔也是如此）**
            - `x = x + 1`中的标量基本类型值2从数字对象中拆封（或者提取）出来后，x就神不知鬼不觉地从引用变成了数字对象，它的值为`2 + 1`等于3，然而函数外的b仍然指向原来那个值为2的数字对象
            - 我们还可以为数字对象添加属性（只要不更改其内部的基本类型值即可），通过它们间接地进行数据交换，不过这种做法不太常见，前面用obj作为封装对象的办法可能更好一些，多数情况下我们应该优先考虑使用标量基本类型，而不是数字等封装对象

## 原生函数
1.  JavaScript中的内建函数也叫原生函数，它们包括
    - String()
    - Number()
    - Boolean()
    - Object()
    - Array()
    - RegExp()
    - Function()
    - Error()
    - Date()
    - Symbol()
2.  JavaScript中的`String()`
    ```javascript
    var s = new String( "Hello World!" );
    console.log( s.toString() ); // "Hello World!"
    var a = new String( "abc" );
    typeof a; // 是"object"，不是"String"
    a instanceof String; // true
    Object.prototype.toString.call( a ); // "[object String]"
    ```
    - 通过构造函数（如`new String("abc")`）创建出来的是封装了基本类型值（如"abc"）的**封装对象**，而非基本类型值
    - `typeof`在这里返回的是对象类型的子类型
    - 可以通过`console.log( a );`来查看封装对象
3.  内部属性`[[class]]`
    - 所有`typeof`返回值为"object"的对象（如数组）都包含一个内部属性`[[Class]]`（它只是一个内部的分类，而非传统的面向对象意义上的类）
    - 这个属性无法直接访问，一般通过`Object.prototype.toString(..)`来查看
        ```javascript
        Object.prototype.toString.call( [1,2,3] );
        // "[object Array]"
        Object.prototype.toString.call( /regex-literal/i );
        // "[object RegExp]"
        ```
        - 数组的内部`[[Class]]`属性值是"Array"，正则表达式的值是"RegExp"。多数情况下，对象的内部`[[Class]]`属性和创建该对象的内建原生构造函数相对应，**但并非总是如此**
    - 基本类型的null与undefined虽然不存在内建函数（原生构造函数），但是内部`[[Class]]`属性值仍然是"Null"和"Undefined"
        ```javascript
        Object.prototype.toString.call( null );
        // "[object Null]"
        Object.prototype.toString.call( undefined );
        // "[object Undefined]"
        ```
    - 其他基本类型值会被各自的封装对象自动包装
        ```javascript
        Object.prototype.toString.call( "abc" );
        // "[object String]"
        Object.prototype.toString.call( 42 );
        // "[object Number]"
        Object.prototype.toString.call( true );
        // "[object Boolean]"
        ```
        - 从ES5到ES6，`toString()`和`[[Class]]`的行为发生了一些变化
4.  封装对象包装
    - JavaScript会自动为基本类型值包装一个封装对象，使其可以访问基本类型没有的属性与方法（`.length`、`.toString()`等）
        ```javascript
        var a = "abc";
        a.length; // 3
        a.toUpperCase(); // "ABC"
        ```
        - 虽然理论上如果需要经常用到这些字符串属性和方法，比如在for循环中使用`i < a.length`，那么从一开始就创建一个封装对象也许更为方便，但实际上因为浏览器已经为`.length`这样的常见情况做了性能优化，直接使用封装对象来“提前优化”代码反而会降低执行效率
        - 一般情况下，我们会让JavaScript引擎自己决定什么时候应该使用封装对象，应该优先考虑使用"abc"和42这样的基本类型值，而非`new String("abc")`和`new Number(42)`
    - 使用封装对象时有些地方需要特别注意，比如`Boolean`
        ```javascript
        var a = new Boolean( false );
        if (!a) {
            console.log( "Oops" ); // 执行不到这里
        }
        ```
        - 我们为false创建了一个封装对象，然而该对象是真值，所以这里使用封装对象得到的结果和使用false截然相反
    - 自行封装基本类型值，可以使用`Object(..)`函数（不带new关键字）
        ```javascript
        var a = "abc";
        var b = new String( a );
        var c = Object( a );
        typeof a; // "string"
        typeof b; // "object"
        typeof c; // "object"
        b instanceof String; // true
        c instanceof String; // true
        Object.prototype.toString.call( b ); // "[object String]"
        Object.prototype.toString.call( c ); // "[object String]"
        ```
    
    **再次强调，一般不推荐直接使用封装对象（如上例中的b和c），但它们偶尔也会派上用场**
5.  拆封：得到封装对象中的基本类型值（使用`valueOf(..)`）
    ```javascript
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );
    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
    ```
    - 在需要用到封装对象中的基本类型值的地方会发生隐式拆封
        ```javascript
        var a = new String( "abc" );
        var b = a + ""; // b的值为"abc"
        typeof a; // "object"
        typeof b; // "string"
        ```
6.  原生函数作为构造函数
    - 关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）
    - Array的构造函数
        ```javascript
        var a = new Array( 1, 2, 3 );
        a; // [1, 2, 3]
        var b = [1, 2, 3];
        b; // [1, 2, 3]
        ```
        - 构造函数`Array(..)`不要求必须带new关键字，不带时，它会被自动补上，因此`Array(1,2,3)`和`new Array(1,2,3)`的效果是一样的
        - Array构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。数组并没有预设长度这个概念，这样创建出来的只是一个空数组，只不过它的length属性被设置成了指定的值。这样数组是空但有长度的数组十分奇特，也会导致一些怪异的行为
            ```javascript
            var a = new Array( 3 );
            a.length; // 3
            a;
            ```
            - a在Chrome中显示为`[ undefined x 3 ]`，这意味着它有三个值为undefined的单元，但实际上单元并不存在
            ```javascript
            var a = new Array( 3 );
            var b = [ undefined, undefined, undefined ];
            var c = [];
            c.length = 3;
            a; 
            b; 
            c;
            ```
            - b在当前版本的Chrome中显示为`[ undefined, undefined, undefined ]`，而a和c则显示为`[ undefined x 3 ]`
            - Firefox中a和c显示为`[ , , , ]`，其中有三个逗号，从ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）
            - 上例中a和b的行为有时相同，有时又大相径庭
                ```javascript
                a.join( "-" ); // "--"
                b.join( "-" ); // "--"
                a.map(function(v,i){ return i; }); // [ undefined x 3 ]
                b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
                ```
                - `a.map(..)`之所以执行失败，是因为数组中并不存在任何单元，所以`map(..)`无从遍历
                - 而`join(..)`具体实现可参考下面的代码，所以它展示出的结果显示a和b行为相同
                    ```javascript
                    function fakeJoin(arr,connector) {
                        var str = "";
                        for (var i = 0; i < arr.length; i++) {
                            if (i > 0) {
                                str += connector;
                            }
                            if (arr[i] !== undefined) {
                                str += arr[i];
                            } 
                        }
                        return str; 
                    }
                    var a = new Array( 3 );
                    fakeJoin( a, "-" ); // "--"
                    ```
                    - 从中可以看出，`join(..)`首先假定数组不为空，然后通过length属性值来遍历其中的元素，而`map(..)`并不做这样的假定，因此结果也往往在预期之外
            -  通过下述方式来创建包含undefined单元（而非“空单元”）的数组
                ```javascript
                var a = Array.apply( null, { length: 3 } );
                a; // [ undefined, undefined, undefined ]
                ```
                - `apply(..)`的第一个参数是this对象，第二个参数则必须是一个数组（或者类似数组的值，也叫作类数组对象），其中的值被用作函数的参数
                - `apply(..)`内部有一个for循环，从0开始循环到length。假设在`apply(..)`内部该数组参数名为arr，for循环就会这样来遍历数组：arr[0]、arr[1]、arr[2]。然而，由于`{ length: 3 }`中并不存在这些属性，所以返回值为undefined
                - 我们执行的实际上是`Array(undefined, undefined, undefined)`，所以结果是单元值为undefined的数组，而非空单元数组
            
            **切记不要创建和使用空单元数组**
    - `Object(..)`、`Function(..)`和`RegExp(..)`
        ```javascript
        var c = new Object();
        c.foo = "bar";
        c; // { foo: "bar" }
        var d = { foo: "bar" };
        d; // { foo: "bar" }
        var e = new Function( "a", "return a * 2;" );
        var f = function(a) { return a * 2; }
        function g(a) { return a * 2; }
        var h = new RegExp( "^a*b+", "g" );
        var i = /^a*b+/g;
        ```
        - 在实际情况中没有必要使用`new Object()`来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定
        - 构造函数Function只在极少数情况下很有用，比如动态定义函数参数和函数体的时候
        - 强烈建议使用常量形式（如`/^a*b+/g`）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为JavaScript引擎在代码执行前会对它们进行预编译和缓存
        - `RegExp(..)`有时还是很有用的，比如动态定义正则表达式时，这种情况在JavaScript编程中时有发生
            ```javascript
            var name = "Kyle";
            var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );
            var matches = someText.match( namePattern );
            ```
    - `Date(..)`和`Error(..)`
        - 相较于其他原生构造函数，`Date(..)`和`Error(..)`的用处要大很多，因为没有对应的常量形式来作为它们的替代
        - 创建日期对象必须使用`new Date()`。`Date(..)`可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间
        - `Date(..)`主要用来获得当前的Unix时间戳（从1970年1月1日开始计算，以秒为单位）。该值可以通过日期对象中的`getTime()`来获得
        - 从ES5开始引入了一个更简单的方法，即静态函数`Date.now()`。对ES5之前的版本我们可以使用下面的polyfill
            ```javascript
            if (!Date.now) {
                Date.now = function(){
                    return (new Date()).getTime();
                };
            }
            ```
        - 如果调用`Date()`时不带new关键字，则会得到当前日期的字符串值。其具体格式规范没有规定，浏览器使用"Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)"这样的格式来显示
        - 构造函数`Error(..)`（与前面的`Array()`类似）带不带new关键字都可
        - 创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分JavaScript引擎通过只读属性`.stack`来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）
            ```javascript
            function foo(x) {
                if (!x) {
                    throw new Error( "x wasn't provided" );
                }
                // .. 
            }
            ```
            - 错误对象通常与throw一起使用
            - 通常错误对象至少包含一个message属性，有时也不乏其他属性（必须作为只读属性访问），如type。除了访问stack属性以外，最好的办法是调用`toString()`来获得经过格式化的便于阅读的错误信息
            - 除`Error(..)`之外，还有一些针对特定错误类型的原生构造函数，如`EvalError(..)`、`RangeError(..)`、`ReferenceError(..)`、`SyntaxError(..)`、`TypeError(..)`和`URIError(..)`。这些构造函数很少被直接使用，它们在程序发生异常时会被自动调用
    - `Symbol(..)`
        - ES6中新加入了一个基本数据类型——符号（Symbol）。符号是具有唯一性的特殊值，用它来命名对象属性不容易导致重名
        - 符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会显示为诸如`Symbol(Symbol.create)`这样的值
        - ES6中有一些预定义符号，以`Symbol`的静态属性形式出现，如`Symbol.create`、`Symbol.iterator`等，可以这样来使用
            ```javascript
            obj[Symbol.iterator] = function(){ /*..*/ };
            ```
        - 我们可以使用`Symbol(..)`原生构造函数来自定义符号。但它比较特殊，不能带new关键字
            ```javascript
            var mysym = Symbol( "my own symbol" );
            mysym; // Symbol(my own symbol)
            mysym.toString(); // "Symbol(my own symbol)"
            typeof mysym; // "symbol"
            var a = { };
            a[mysym] = "foobar";
            Object.getOwnPropertySymbols( a );
            // [ Symbol(my own symbol) ]
            ```
            - 虽然符号实际上并非私有属性（通过`Object.getOwnPropertySymbols(..)`便可以公开获得对象中的所有符号），但它却主要用于私有或特殊属性。很多开发人员喜欢用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性
        - 符号并非对象，而是一种简单标量基本类型
    - 原生原型
        - 原生构造函数有自己的`.prototype`对象，如`Array.prototype`、`String.prototype`等。这些对象包含其对应子类型所特有的行为特征。例如将字符串值封装为字符串对象之后，就能访问`String.prototype`中定义的方法
        - `String.prototype.indexOf(..)`，在字符串中找到指定子字符串的位置
        - `String.prototype.charAt(..)`，获得字符串指定位置上的字符
        - `String.prototype.substr(..)`、`String.prototype.substring(..)`和`String.prototype.slice(..)`，获得字符串的指定部分
        - `String.prototype.toUpperCase()`和`String.prototype.toLowerCase()`，将字符串转换为大写或小写
        - `String.prototype.trim()`，去掉字符串前后的空格，返回新的字符串
        - 以上方法并不改变原字符串的值，而是返回一个新字符串
        - 基于原型委托所有字符串都可以访问这些方法
            ```javascript
            var a = " abc ";
            a.indexOf( "c" ); // 3
            a.toUpperCase(); // " ABC "
            a.trim(); // "abc"
            ```
        - 其他构造函数的原型包含它们各自类型所特有的行为特征，比如`Number.prototype.tofixed(..)`（将数字转换为指定长度的整数字符串）和 `Array.prototype.concat(..)`（合并数组）。所有的函数都可以调用`Function.prototype`中的`apply(..)`、`call(..)`和`bind(..)`
        - 有些原生原型（native prototype）并非普通对象那么简单，`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组
            ```javascript
            typeof Function.prototype; // "function"
            Function.prototype(); // 空函数！
            RegExp.prototype.toString(); // "/(?:)/"——空正则表达式
            "abc".match( RegExp.prototype ); // [""]
            ```
        - 我们甚至可以修改它们（而不仅仅是添加属性）
            ```javascript
            Array.isArray( Array.prototype ); // true
            Array.prototype.push( 1, 2, 3 ); // 3
            Array.prototype; // [1,2,3]
            // 需要将Array.prototype设置回空，否则会导致问题！
            Array.prototype.length = 0;
            ```
        - 将原型作为默认值。`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”的正则表达式（无任何匹配），而`Array.prototype`是一个空数组。对未赋值的变量来说，它们是很好的默认值
            ```javascript
            function isThisCool(vals,fn,rx) {
                vals = vals || Array.prototype;
                fn = fn || Function.prototype;
                rx = rx || RegExp.prototype;
                return rx.test(
                    vals.map( fn ).join( "" )
                ); 
            }
            isThisCool(); // true
            isThisCool(
                ["a","b","c"],
                function(v){ return v.toUpperCase(); },
                /D/
            ); // false
            ```
            - 从ES6开始，我们不再需要使用`vals = vals || ..`这样的方式来设置默认值，因为默认值可以通过函数声明中的内置语法来设置
            - 这种方法的一个好处是`.prototypes`已被创建并且仅创建一次，如果将`[]`、`function(){}`和`/(?:)/`作为默认值，则每次调用`isThisCool(..)`时它们都会被创建一次，这样无疑会造成内存和CPU资源的浪费
            - 另外需要注意的一点是，如果默认值随后会被更改，那就不要使用`Array.prototype`。上例中的vals是作为只读变量来使用，更改vals实际上就是更改`Array.prototype`，修改`.prototype`会导致前面提到过的一系列问题

## 强制类型转换
1.  将值从一种类型转换为另一种类型通常称为**类型转换**，这是显式的情况；隐式的情况称为强制类型转换
2.  JavaScript中的强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数
3.  类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时；然而在JavaScript中通常将它们统称为强制类型转换。在实际代码中，我们能够从代码中看出哪些地方是显式强制类型转换，而隐式强制类型转换则不那么明显，通常是某些操作产生的副作用
    ```javascript
    var a = 42;
    var b = a + ""; // 隐式强制类型转换
    var c = String( a ); // 显式强制类型转换
    ```
    - 除了字面上的差别以外，二者在行为特征上也有一些细微的差别
4.  ES5规范第9节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。这里我们着重介绍`ToString`、`ToNumber`和`ToBoolean`，附带讲一讲`ToPrimitive`
    - `toString`，它负责处理非字符串到字符串的强制类型转换
        - 基本类型值的字符串化规则为：null转换为"null"，undefined转换为"undefined"，true转换为"true"。数字的字符串化则遵循通用规则，不过那些极小和极大的数字使用指数形式
            ```javascript
            // 1.07 连续乘以七个 1000
            var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
            // 七个1000一共21位数字
            a.toString(); // "1.07e21"
            ```
        - 对普通对象来说，除非自行定义，否则`toString()`（`Object.prototype.toString()`）返回内部属性`[[Class]]`的值如`"[object Object]"`
        - 数组的默认`toString()`方法经过了重新定义，将所有单元字符串化以后再用","连接起来
            ```javascript
            var a = [1,2,3];
            a.toString(); // "1,2,3"
            ```
        - `toString()`可以被显式调用，或者在需要字符串化时自动调用
        - 工具函数`JSON.stringify(..)`在将JSON对象序列化为字符串时也用到了`toString()`。JSON字符串化并非严格意义上的强制类型转换，因为其中也涉及`toString()`的相关规则
        - 对大多数简单值来说，JSON字符串化和`toString()`的效果基本相同
            ```javascript
            JSON.stringify( 42 ); // "42"
            JSON.stringify( "42" ); // ""42"" （含有双引号的字符串）
            JSON.stringify( null ); // "null"
            JSON.stringify( true ); // "true"
            ```
            - 所有安全的JSON值（JSON-safe）都可以使用`JSON.stringify(..)`字符串化。安全的JSON值是指能够呈现为有效JSON格式的值
            - 不安全的JSON值包括：undefined、function、symbol（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合JSON结构标准
        - `JSON.stringify(..)`在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null（以保证单元位置不变）
            ```javascript
            JSON.stringify( undefined ); // undefined
            JSON.stringify( function(){} ); // undefined
            JSON.stringify(
                [1,undefined,function(){},4]
            ); // "[1,null,null,4]"
            JSON.stringify(
                { a:2, b:function(){} }
            ); // "{"a":2}"
            ```
        - 对包含循环引用的对象执行`JSON.stringify(..)`会出错
        - 如果对象中定义了`toJSON()`方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化
        - 如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法来返回一个安全的JSON值
            ```javascript
            var o = { };
            var a = { 
                b: 42,
                c: o,
                d: function(){}
            };
            // 在a中创建一个循环引用
            o.e = a;
            // 循环引用在这里会产生错误
            // JSON.stringify( a );
            // 自定义的JSON序列化
            a.toJSON = function() {
                // 序列化仅包含b
                return { b: this.b };
            };
            JSON.stringify( a ); // "{"b":42}"
            ```
            - 很多人误以为`toJSON()`返回的是JSON字符串化后的值，其实`toJSON()`返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify(..)`对其进行字符串化。也就是说，`toJSON()`应该“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”
                ```javascript
                var a = {
                    val: [1,2,3],
                    // 可能是我们想要的结果！
                    toJSON: function(){
                        return this.val.slice( 1 );
                    }
                };
                var b = {
                    val: [1,2,3],
                    // 可能不是我们想要的结果！
                    toJSON: function(){
                        return "[" +
                            this.val.slice( 1 ).join() +
                        "]"; 
                    }
                };
                JSON.stringify( a ); // "[2,3]"
                JSON.stringify( b ); // ""[2,3]""
                ```
                - 这里第二个函数是对toJSON返回的字符串做字符串化，而非数组本身
        - 我们可以向`JSON.stringify(..)`传递一个可选参数replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除
            ```javascript
            var a = { 
                b: 42,
                c: "42",
                d: [1,2,3] 
            };
            JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
            JSON.stringify( a, function(k,v){
                if (k !== "c") return v;
            } );
            // "{"b":42,"d":[1,2,3]}"
            ```
            - 如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略
            - 如果replacer是一个函数，每次传递两个参数，键和值。如果要忽略某个键就返回undefined，否则返回指定的值
        - `JSON.stringify`还有一个可选参数space，用来指定输出的缩进格式。space为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进
            ```javascript
            var a = { 
                b: 42,
                c: "42",
                d: [1,2,3] 
            };
            JSON.stringify( a, null, 3 );
            // "{
            //      "b": 42,
            //      "c": "42",
            //      "d": [
            //          1, 
            //          2,
            //          3
            //      ]
            // }"
            JSON.stringify( a, null, "-----" );
            // "{
            // -----"b": 42,
            // -----"c": "42",
            // -----"d": [
            // ----------1,
            // ----------2,
            // ----------3
            // -----]
            // }"
            ```
        - `JSON.stringify(..)`并不是强制类型转换
            - 字符串、数字、布尔值和null的`JSON.stringify(..)`规则与`toString`基本相同
            - 如果传递给`JSON.stringify(..)`的对象中定义了`toJSON()`方法，那么该方法会在字符串化前调用，以便将对象转换为安全的JSON值
    - `toNumber`
        - 有时我们需要将非数字值当作数字来使用，其中true转换为1，false转换为0。undefined转换为NaN，null转换为0
        - `toNumber`对字符串的处理基本遵循数字常量的相关规则/语法。处理失败时返回NaN（处理数字常量失败时会产生语法错误）。不同之处是`toNumber`对以0开头的十六进制数并不按十六进制处理（而是按十进制）
        - 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字
        - 为了将值转换为相应的基本类型值，抽象操作`toPrimitive`会首先检查该值是否有`valueOf()`方法（用于获取包装对象内的基本类型值）。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用`toString()`的返回值来进行强制类型转换。如果`valueOf()`和`toString()`均不返回基本类型值，会产生TypeError错误
        - 从ES5开始，使用`Object.create(null)`创建的对象`[[Prototype]]`属性为null，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换
            ```javascript
            var a = {
                valueOf: function(){
                    return "42";
                }
            };
            var b = {
                toString: function(){
                    return "42";
                }
            };
            var c = [4,2];
            c.toString = function(){
                return this.join( "" ); // "42"
            };
            Number( a ); // 42
            Number( b ); // 42
            Number( c ); // 42
            Number( "" ); // 0
            Number( [] ); // 0
            Number( [ "abc" ] ); // NaN
            ```
    - `toBoolean`
        - 在JavaScript中布尔值true和false并不等同于数值1和0。虽然我们可以将1强制类型转换为true，将0强制类型转换为false，反之亦然、
        - JavaScript中的值可以分为以下两类：可以被强制类型转换为false的值；其他（被强制类型转换为true的值）
        - JavaScript规范具体定义了一小撮可以被强制类型转换为false的值（这些值又被称作假值）
            - undefined
            - null
            - false
            - +0、-0和NaN
            - ""
        - 假值列表以外的值都是真值
        - 假值对象，假值对象并不是包装了假值的封装对象
            ```javascript
            var a = new Boolean( false );
            var b = new Number( 0 );
            var c = new String( "" );
            var d = Boolean( a && b && c );
            d; // true
            ```
            - d为true，说明a、b、c都为true
        - 浏览器在某些特定情况下，在常规JavaScript语法基础上自己创建了一些外来（exotic）值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false
        - 最常见的例子是`document.all`，它是一个类数组对象，包含了页面上的所有元素，由DOM提供给JavaScript程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为true，不过现在它是一个假值对象
            - `document.all`是假值的原因是，我们经常通过将`document.all`强制类型转换为布尔值（比如在if语句中）来判断浏览器是否是老版本的IE`if(document.all) { /* it's IE */ }`。但为了让新版本更符合标准，IE并不打算继续支持`if (document.all) { .. }`，因此将`document.all`作为假值来处理
        - 真值就是假值列表之外的值
            ```javascript
            var a = "false";
            var b = "0";
            var c = "''";
            var d = Boolean( a && b && c );
            d;    // true
            ```
            - 上例的字符串看似假值，但所有字符串都是真值，除了假值列表中唯一的字符串""
            ```javascript
            var a = []; // 空数组——是真值还是假值？
            var b = {}; // 空对象——是真值还是假值？
            var c = function(){}; // 空函数——是真值还是假值？
            var d = Boolean( a && b && c );
            d;    // true
            ```
            - `[]`、`{}`和`function(){}`都不在假值列表中，因此它们都是真值
        - 真值列表可以无限长，无法一一列举，所以我们只能用假值列表作为参考
5.  显式强制类型转换
    - 显式强制类型转换是那些显而易见的类型转换，很多类型转换都属于此列，它类似于静态语言中的类型转换
    - 字符串和数字之间的显式转换
        - 字符串和数字之间的转换是通过`String(..)`和`Number(..)`这两个内建函数来实现的，请注意它们前面没有new关键字，并不创建封装对象
            ```javascript
            var a = 42;
            var b = String( a );
            var c = "3.14";
            var d = Number( c );
            b; // "42"
            d; // 3.14
            ```
            - `String(..)`遵循前面讲过的`toString`规则，将值转换为字符串基本类型。`Number(..)`遵循前面讲过的`toNumber`规则，将值转换为数字基本类型
            - 它们和静态语言中的类型转换很像，一目了然，所以我们将它们归为显式强制类型转换。。JavaScript中的`Number(x)`与C/C++中`int(x)`十分类似
        - 除了`String(..)`和`Number(..)`以外，还有其他方法可以实现字符串和数字之间的显式转换
            ```javascript
            var a = 42;
            var b = a.toString();
            var c = "3.14";
            var d = +c;
            b; // "42"
            d; // 3.14
            ```
            - `a.toString()`是显式的，不过其中涉及隐式转换。因为`toString()`对42这样的基本类型值不适用，所以JavaScript引擎会自动为42创建一个封装对象，然后对该对象调用`toString()`)。这里显式转换中含有隐式转换
            - `+c`是+运算符的一元（unary）形式。+运算符显式地将c转换为数字，而非数字加法运算。在JavaScript开源社区中，一元运算+被普遍认为是显式强制类型转换
            - +、-运算符的一元形式也容易产生误会
                ```javascript
                var c = "3.14";
                var d = 5+ +c;
                d; // 8.14
                ```
                - 由于`--`会被当作递减运算符来处理，所以我们不能使用`--`来撤销反转，而应该像`- -"3.14"`这样，在中间加一个空格，才能得到正确结果3.14
                - 运算符的一元和二元形式的组合你也许能够想到很多种情况`1 + - + + + - + 1; // 2`，尽量不要把一元运算符+（还有-）和其他运算符放在一起使用
                - 此外`d = +c`（还有`d =+ c`）也容易和`d += c`搞混，两者天壤之别
    - 日期显式转换为数字
        - 一元运算符+的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为Unix时间戳，以微秒为单位（从1970年1月1日00:00:00 UTC到当前时间）
            ```javascript
            var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );
            +d; // 1408369986000
            ```
        - 我们常用`var timestamp = +new Date();`的方法来获得当前的时间戳
        - JavaScript有一处奇特的语法，即构造函数没有参数时可以不用带()。于是我们可能会碰到`var timestamp = +new Date;`这样的写法
        - 将日期对象转换为时间戳并非只有强制类型转换这一种方法，或许使用更显式的方法会更好一些
            ```javascript
            var timestamp = new Date().getTime();
            // var timestamp = (new Date()).getTime();
            // var timestamp = (new Date).getTime();
            ```
        - 最好还是使用ES5中新加入的静态方法`Date.now()`；`var timestamp = Date.now();`
        - 为老版本浏览器提供`Date.now()`的polyfill也很简单
            ```javascript
            if (!Date.now) {
                Date.now = function() {
                    return +new Date();
                };
            }
            ```
        - 我们不建议对日期类型使用强制类型转换，应该使用`Date.now()`来获得当前的时间戳，使用`new Date(..).getTime()`来获得指定时间的时间戳
    - ~运算符
        - 一个常被人忽视的地方是~运算符（即字位操作“非”）相关的强制类型转换
        - 字位运算符（|、~）只适用于32位整数，运算符会强制操作数使用32位格式。这是通过抽象操作`toInt32`来实现的。`toInt32`首先执行 `toNumber`强制类型转换，比如"123"会先被转换为123，然后再执行`toInt32`
        - 字位运算符严格说来并非强制类型转换（因为返回值类型并没有发生变化），但和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字
            ```javascript
            0 | -0; // 0
            0 | NaN; // 0
            0 | Infinity; // 0
            0 | -Infinity; // 0
            ```
            - |运算符（字位操作“或”）的空操作（no-op）`0 | x`，它仅执行`toInt32`转换
            - 以上这些特殊数字无法以32位格式呈现，因此`toInt32`返回0
        - ~首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）
        - ~的另外一种诠释是~返回2的补码，`~x`大致等同于`-(x+1)`；`~42; // -(42+1) ==> -43`
            - 在`-(x+1)`中唯一能够得到0（或者严格说是-0）的x值是-1，其他情况则返回真值
            - -1是一个“哨位值”，被赋予了特殊含义的值。例如字符串的`indexOf(..)`方法，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从0开始），否则返回-1。因此还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断
                ```javascript
                var a = "Hello World";
                if (a.indexOf( "lo" ) >= 0) { // true
                    // 找到匹配！
                }
                if (a.indexOf( "lo" ) != -1) { // true
                    // 找到匹配！
                }
                if (a.indexOf( "ol" ) < 0) { // true
                    // 没有找到匹配！
                }
                if (a.indexOf( "ol" ) == -1) { // true
                    // 没有找到匹配！
                }
                ```
                - `>= 0`和`== -1`这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这些细节应该被屏蔽掉
            - ~和`indexOf()`一起可以将结果强制类型转换为真/假值
                ```javascript
                var a = "Hello World";
                ~a.indexOf( "lo" ); // -4 <-- 真值!
                if (~a.indexOf( "lo" )) { // true
                    // 找到匹配！
                }
                ~a.indexOf( "ol" ); // 0 <-- 假值!
                !~a.indexOf( "ol" ); // true
                if (!~a.indexOf( "ol" )) { // true
                    // 没有找到匹配！
                }
                ```
                - 如果`indexOf(..)`返回-1，~将其转换为假值0，其他情况一律转换为真值
                - 由`-(x+1)`推断`~-1`的结果应该是-0，然而实际上结果是0，因为它是字位操作而非数学运算
                - `if (~a.indexOf(..))`仍然是对`indexOf(..)`的返回结果进行隐式强制类型转换，0转换为false，其他情况转换为true
        - 字位截除
            - 一些开发人员使用`~~`来截除数字值的小数部分，`~~`中的第一个~执行`toInt32`并反转字位，然后第二个~再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是`toInt32`的结果
            - `~~`首先它只适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同
                ```javascript
                Math.floor( -49.6 ); // -50
                ~~-49.6; // -49
                ```
            - `~~x`能将值截除为一个32位整数，`x | 0`也可以，而且看起来还更简洁
            - `~~`与`|`运算符的优先级
                ```javascript
                ~~1E20 / 10; // 166199296
                1E20 | 0 / 10; // 1661992960
                (1E20 | 0) / 10; // 166199296
                ```
                - `~~`运算符的优先级高于乘除法；而`|`运算符优先级低于乘除法
    - 显式解析数字字符串
        - 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别
            ```javascript
            var a = "42";
            var b = "42px";
            Number( a ); // 42
            parseInt( a ); // 42
            Number( b ); // NaN
            parseInt( b ); // 42
            ```
            - 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN
            - 解析字符串中的浮点数可以使用`parseFloat(..)`函数
        - `parseInt(..)`针对的是字符串值。向`parseInt(..)`传递数字和其他类型的参数是没有用的，比如`true`、`function(){...}`和`[1,2,3]`。非字符串参数会首先被强制类型转换为字符串，然后再传入到`parseInt(..)`，依赖这样的隐式强制类型转换并非上策，应该避免向`parseInt(..)`传递非字符串参数
        - ES5之前的`parseInt(..)`有一个坑导致了很多bug。即如果没有第二个参数来指定转换的基数，`parseInt(..)`会根据字符串的第一个字符来自行决定基数。如果第一个字符是x或X，则转换为十六进制数字。如果是0，则转换为八进制数字
            ```javascript
            var hour = parseInt( selectedHour.value );
            var minute = parseInt( selectedMinute.value );
            console.log(
                "The time you selected was: " + hour + ":" + minute
            );
            ```
            - 以x和X开头的十六进制相对来说还不太容易搞错，而八进制则不然。上面的代码看似没有问题，但是当小时为08、分钟为09时，结果是0:0，因为8和9都不是有效的八进制数。将第二个参数设置为10，即可避免这个问题
            ```javascript
            var hour = parseInt( selectedHour.value, 10 );
            var minute = parseInt( selectedMiniute.value, 10 );
            ```
        - 从ES5开始`parseInt(..)`默认转换为十进制数，除非另外指定。如果你的代码需要在ES5之前的环境运行，请记得将第二个参数设置为10
        - 解析非字符串的坑`parseInt( 1/0, 19 ); // 18`
            - `parseInt(..)`先将参数强制类型转换为字符串再进行解析
                ```javascript
                var a = {
                    num: 21,
                    toString: function() { return String( this.num * 2 ); }
                };
                parseInt( a ); // 42
                ```
                - JavaScript先会调用a对象的`toString()`方法强制转换成String类型，然后再解析`parseInt()`
            - `parseInt()`的第一个参数由于传递了非字符串Infinity，JavaScript会将参数强制类型转换为它能够处理的字符串`"Infinity"`
            - `parseInt()`的第二个参数是基数19，`"Infinity"`的第一个字符是"I"，以19为基数时值为18。第二个字符"n"不是一个有效的数字字符，解析到此为止
            - 此外还有一些看起来奇怪但实际上解释得通的例子
                ```javascript
                parseInt( 0.000008 ); // 0 ("0" 来自于 "0.000008")
                parseInt( 0.0000008 ); // 8 ("8" 来自于 "8e-7")
                parseInt( false, 16 ); // 250 ("fa" 来自于 "false")
                parseInt( parseInt, 16 ); // 15 ("f" 来自于 "function..")
                parseInt( "0x10" ); // 16
                parseInt( "103", 2 ); // 2
                ```
                - 其中`parseInt( false, 16 );`是因为基数为16（0-9，a-f），`fa===15*16^1+10*16^0===250`
                - 其中`parseInt( "103", 2 );`是因为基数为2，3是无效字符，所以`10===1*2^1+0*2^0===2`
    - 显式转换为布尔值
        - 与前面的`String(..)`和`Number(..)`一样，`Boolean(..)`（不带new）是显式的`toBoolean`强制类型转换
            ```javascript
            var a = "0";
            var b = [];
            var c = {};
            var d = "";
            var e = 0;
            var f = null;
            var g;
            Boolean( a ); // true
            Boolean( b ); // true
            Boolean( c ); // true
            Boolean( d ); // false
            Boolean( e ); // false
            Boolean( f ); // false
            Boolean( g ); // false
            ```
        - 一元运算符!显式地将值强制类型转换为布尔值，但是它同时还将真值反转为假值（或者将假值反转为真值）。所以显式强制类型转换为布尔值最常用的方法是`!!`，因为第二个!会将结果反转回原值
            ```javascript
            var a = "0";
            var b = [];
            var c = {};
            var d = "";
            var e = 0;
            var f = null;
            var g;
            !!a; // true
            !!b; // true
            !!c; // true
            !!d; // false
            !!e; // false
            !!f; // false
            !!g; // false
            ```
        - 在`if(..)..`这样的布尔值上下文中，如果没有使用`Boolean(..)`和`!!`，就会自动隐式地进行`toBoolean`转换
        - 显式`toBoolean`的另外一个用处，是在JSON序列化过程中将值强制类型转换为true或false
            ```javascript
            var a = [ 
                1,
                function(){ /*..*/ },
                2,
                function(){ /*..*/ }
            ];
            JSON.stringify( a ); // "[1,null,2,null]"
            JSON.stringify( a, function(key,val){
                if (typeof val == "function") {
                    // 函数的ToBoolean强制类型转换
                    return !!val;
                }
                else {
                    return val;
                }
            } );
            // "[1,true,2,true]"
            ```
            - 因为正常情况下，由于function并不是安全的JSON值，所以在数组中会返回null进行占位（而不是undefined），这时可以利用显式的toBoolean类型转换先将function函数转换成布尔类型值，再进行JSON的序列化

            ```javascript
            var a = 42;
            var b = a ? true : false;
            ```
            - 表面上这是一个显式的`toBoolean`强制类型转换，因为返回结果是true或者false，然而这里涉及隐式强制类型转换，因为a要首先被强制类型转换为布尔值才能进行条件判断
        



