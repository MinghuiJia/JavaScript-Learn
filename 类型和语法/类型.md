<!--
 * @Author: jiaminghui
 * @Date: 2022-12-31 15:34:02
 * @LastEditTime: 2022-12-31 23:21:01
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\类型和语法\类型.md
 * @Description: 
-->
# JavaScript类型的学习

## 类型
1.  大多数开发者认为，像JavaScript这样的动态语言是没有类型（type）的，但是ES5规范中规定**运算法则所操纵的值均有相应的类型**。在ECMAScript中类型包括：
    - Number
    - String
    - Boolean
    - Null
    - Undefined
    - Object
    - Symbol（ES6中新增的）
**除了对象类型外，其他的统称为基本类型**
2.  有人认为JavaScript中的“类型”应该称为“标签”（tag）或者“子类型”（subtype），而JavaScript中认为自己有类型，并把类型定义为：对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。针对42和"42"，开发人员与引擎采取不同的处理方式，对数字42进行数学运算，而对字符串"42"进行字符串操作，比如输出到页面。因此它们是不同的类型
3.  深入了解类型，有助于**正确合理地进行类型转换（强制类型转换）**
4.  我们可以使用`typeof`运算符来查看值的类型，它返回的是类型的字符串值
    ```javascript
    typeof undefined === "undefined"; // true
    typeof true === "boolean"; // true
    typeof 42 === "number"; // true
    typeof "42" === "string"; // true
    typeof { life: 42 } === "object"; // true
    // ES6中新加入的类型
    typeof Symbol() === "symbol"; // true

    typeof null === "object"; // true
    ```
    - 上述返回的类型字符串，除了null之外都有同名的字符串值与之对应，为了检查null值的类型需要使用复合条件
        ```javascript
        var a = null;
        (!a && typeof a === "object"); // true
        ```
    - function（函数）不是JavaScript的内置类型，而是object的一个“子类型”。函数是“可调用对象”，它有一个内部属性`[[Call]]`，该属性使其可以被调用
        ```javascript
        typeof function a(){ /* .. */ } === "function"; // true
        ```
    - 函数不仅是对象，还可以拥有属性，函数对象的length属性是其声明的参数的个数
        ```javascript
        function a(b,c) {
            /* .. */
        }
        a.length; // 2
        ```
    - JavaScript支持数组，数组也是Object的一个“子类型”，数组的元素按数字顺序来进行索引，其length属性是元素的个数
        ```javascript
        typeof [1,2,3] === "object"; // true
        ```
5.  JavaScript中的变量是没有类型的，**只有值才有**，变量可以随时持有任何类型的值。语言引擎不要求变量总是持有与其初始值同类型的值
    - 在对变量执行`typeof`操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为JavaScript中的变量没有类型
        ```javascript
        var a = 42;
        typeof a; // "number"
        a = true;
        typeof a; // "boolean"
        ```
    - `typeof`运算符总是会返回一个字符串
        ```javascript
        typeof typeof 42; // "string"
        ```
    - 变量在未持有值的时候为undefined。此时`typeof`返回"undefined"
        ```javascript
        var a;
        typeof a; // "undefined"
        var b = 42;
        var c;
        // later 
        b = c;
        typeof b; // "undefined"
        typeof c; // "undefined"
        ```
    - 在JavaScript中undefined不等同于undeclared（未声明），已在作用域中声明但还没有赋值的变量，是undefined的；还没有在作用域中声明过的变量，是undeclared的
        ```javascript
        var a;
        a; // undefined
        b; // ReferenceError: b is not defined "b is not found" 或者 "b is not declared"会更准确
        ```
        - 此外，使用`typeof`并不能区分变量是undeclared还是undefined
            ```javascript
            var a;
            typeof a; // "undefined"
            typeof b; // "undefined"
            ```
            - 这是因为`typeof`有一个特殊的安全防范机制
6.  JavaScript中typeof Undeclared的用处
    - 在程序中使用全局变量DEBUG作为“调试模式”的开关。在输出调试信息到控制台之前，我们会检查DEBUG变量是否已被声明。顶层的全局变量声明`var DEBUG = true`只在debug.js文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环境中不予加载
    - 如何在程序中检查全局变量DEBUG才不会出现ReferenceError错误，这时`typeof`的安全防范机制就成了我们的好帮手
        ```javascript
        // 这样会抛出错误
        if (DEBUG) {
            console.log( "Debugging is starting" );
        }
        // 这样是安全的
        if (typeof DEBUG !== "undefined") {
            console.log( "Debugging is starting" );
        }
        ```
    - 这不仅对用户定义的变量（比如DEBUG）有用，对内建的API也有帮助
        ```javascript
        if (typeof atob === "undefined") {
            atob = function() { /*..*/ };
        }
        ```
    - 另一种不用通过`typeof`的安全防范机制的方法，就是检查所有全局变量是否是全局对象的属性，浏览器中的全局对象是window
        ```javascript
        if (window.DEBUG) {
            // ..
        }
        if (!window.atob) {
            // ..
        }
        ```
        - 与undeclared变量不同，访问不存在的对象属性（甚至是在全局对象window上）不会产生ReferenceError错误，而是会返回undefined值
        - 另外当代码需要运行在多种JavaScript环境中时（不仅仅是浏览器，还有服务器端，如 node.js 等）此时全局对象并非总是window，检查全局变量是否是全局对象的属性就会给代码编写造成问题
    - typeof的安全防范机制对于非全局变量也很管用，如果想让别人在他们的程序或模块中复制粘贴你的代码，就需要检查你用到的变量是否已经在宿主程序中定义过
        ```javascript
        // 一个立即执行函数表达式（IIFE，参见《你不知道的JavaScript（上卷）》“作用域和闭包”
        // 部分的3.3.2节）
        (function(){
            function FeatureXYZ() { /*.. my XYZ feature ..*/ }
            // 包含doSomethingCool(..)
            function doSomethingCool() {
                var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
                var val = helper();
                // .. 
            }
            doSomethingCool();
        })();
        ```
        - 其他模块和程序引入`doSomethingCool()`时，`doSomethingCool()`会检查`FeatureXYZ`变量是否已经在宿主程序中定义过；如果是，就用现成的，否则就自己定义
        - 上述代码FeatureXYZ并不是一个全局变量，但我们还是可以使用`typeof`的安全防范机制来做检查，因为这里没有全局对象可用
    - 还有一些人喜欢使用“依赖注入”（dependency injection）设计模式，就是将依赖通过参数显式地传递到函数中
        ```javascript
        function doSomethingCool(FeatureXYZ) {
            var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
            var val = helper();
            // ..
        }
        ```
## 值
1.  数组在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组
    ```javascript
    var a = [ 1, "2", [3] ];
    a.length; // 3
    a[0] === 1; // true
    a[2][0] === 3; // true
    ```
    - 对数组声明后即可向其中加入值，不需要预先设定大小
        ```javascript
        var a = [ ];
        a.length; // 0
        a[0] = 1;
        a[1] = "2";
        a[2] = [ 3 ];
        a.length; // 3
        ```
        - 使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化
    - 在创建“稀疏”数组（sparse array，即含有空白或空缺单元的数组）时要特别注意
        ```javascript
        var a = [ ];
        a[0] = 1;
        // 此处没有设置a[1]单元
        a[2] = [ 3 ];
        a[1]; // undefined
        a.length; // 3
        ```
        - 上面的代码可以正常运行，但其中的“空白单元”（empty slot）为undefined。a[1]的值为undefined，但这与将其显式赋值为undefined（`a[1] = undefined`）还是有所区别
    - 数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）
        ```javascript
        var a = [ ];
        a[0] = 1;
        a["foobar"] = 2;
        a.length; // 1
        a["foobar"]; // 2
        a.foobar; // 2
        ```
        - 如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理
            ```javascript
            var a = [ ];
            a["13"] = 42;
            a.length; // 14
            ```
        
        **注意：在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值，用数组来存放数字索引值**
2.  类数组：有时需要将类数组（一组通过数字索引的值）转换为真正的数组，这一般通过数组工具函数（如`indexOf(..)`、`concat(..)`、`forEach(..)`等）来实现
    - 一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）
    - 工具函数`slice(..)`经常被用于这类转换
        ```javascript
        function foo() {
            var arr = Array.prototype.slice.call( arguments );
            arr.push( "bam" );
            console.log( arr );
        }
        foo( "bar", "baz" ); // ["bar","baz","bam"]
        ```
        - 如上所示，`slice()`返回参数列表（上例中是一个类数组）的一个数组复本
        - 用ES6中的内置工具函数`Array.from(..)`也能实现同样的功能`var arr = Array.from( arguments );`
3.  字符串
    - 字符串经常被当成字符数组，但JavaScript中的字符串和字符数组并不是一回事，最多只是看上去相似而已
    - 字符串与字符数组都有`length`属性以及`indexOf(..)`（从ES5开始数组支持此方法）和`concat(..)`方法
        ```javascript
        var a = "foo";
        var b = ["f","o","o"];
        a.length; // 3
        b.length; // 3
        a.indexOf( "o" ); // 1
        b.indexOf( "o" ); // 1
        var c = a.concat( "bar" ); // "foobar"
        var d = b.concat( ["b","a","r"] ); // ["f","o","o","b","a","r"]
        a === c; // false
        b === d; // false
        a; // "foo" 
        b; // ["f","o","o"]
        ```
    - 但本质上字符串与字符数组不能等价
        ```javascript
        a[1] = "O";
        b[1] = "O";
        a; // "foo"
        b; // ["f","O","o"]
        ```
        - JavaScript中字符串是不可变的，而数组是可变的。并且`a[1]`在JavaScript中并非总是合法语法，在老版本的IE中就不被允许。正确的方法应该是`a.charAt(1)`
    - 字符串不可变是指字符串的成员函数不会改变其原始值，而是**创建并返回一个新的字符串**。而数组的成员函数都是在其原始值上进行操作
        ```javascript
        c = a.toUpperCase();    // 字符串的成员函数toUpperCaae会返回一个新的字符串
        a === c; // false
        a; // "foo"
        c; // "FOO"
        b.push( "!" );
        b; // ["f","O","o","!"]
        ```
    - 许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串
        ```javascript
        a.join; // undefined
        a.map; // undefined
        var c = Array.prototype.join.call( a, "-" );
        var d = Array.prototype.map.call( a, function(v){
            return v.toUpperCase() + ".";
        } ).join( "" );
        c; // "f-o-o"
        d; // "F.O.O."
        ```
    - 此外重要的一点区别是**字符串反转（JavaScript 面试常见问题）**。数组有一个字符串没有的可变更成员函数`reverse()`
        ```javascript
        a.reverse; // undefined
        b.reverse(); // ["!","o","O","f"]
        b; // ["f","O","o","!"]
        ```
        - 可惜我们无法“借用”数组的可变更成员函数，因为字符串是不可变的。`Array.prototype.reverse.call( a );`返回的仍然是字符串"foo"的一个封装对象
        - 一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串
            ```javascript
            var c = a
                // 将a的值转换为字符数组
                .split( "" )
                // 将数组中的字符进行倒转
                .reverse()
                // 将数组中的字符拼接回字符串
                .join( "" );
            c; // "oof"
            ```
            - 上述方法对于包含复杂字符（Unicode，如星号、多字节字符等）的字符串并不适用。需要功能更加完备、能够处理Unicode的工具库来完成

        **如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在字符串和数组之间来回折腾。可以在需要时使用`join("")`将字符数组转换为字符串**
4.  数字
    - JavaScript只有一种数值类型：number（数字），包括“整数”和带小数的十进制数
    - JavaScript中的“整数”就是没有小数的十进制数。所以42.0即等同于“整数”42
    - 数字的语法
        - JavaScript中的数字常量一般用十进制表示
            ```javascript
            var a = 42;
            var b = 42.3;
            ```
        - 数字前面的0可以省略
            ```javascript
            var a = 0.42;
            var b = .42;
            ```
        - 小数点后小数部分最后面的0也可以省略
            ```javascript
            var a = 42.0;
            var b = 42.;
            ```
            - 42.这种写法没问题，只是不常见，但从代码的可读性考虑，不建议这样写
        - 默认情况下大部分数字都以十进制显示，小数部分最后面的0被省略
            ```javascript
            var a = 42.300;
            var b = 42.0;
            a; // 42.3
            b; // 42
            ```
        - 特别大和特别小的数字默认用指数格式显示，与`toExponential()`函数的输出结果相同
            ```javascript
            var a = 5E10;
            a; // 50000000000
            a.toExponential(); // "5e+10"
            var b = a * a;
            b; // 2.5e+21
            var c = 1 / a;
            c; // 2e-11
            ```
        - 由于数字值可以使用Number对象进行封装，因此数字值可以调用Number.prototype中的方法。例如，`tofixed(..)`方法可指定小数部分的显示位数
            ```javascript
            var a = 42.59;
            a.toFixed( 0 ); // "43"
            a.toFixed( 1 ); // "42.6"
            a.toFixed( 2 ); // "42.59"
            a.toFixed( 3 ); // "42.590"
            a.toFixed( 4 ); // "42.5900"
            ```
            - 上例中的输出结果实际上是**给定数字的字符串形式**，如果指定的小数部分的显示位数多于实际位数就用0补齐
        - `toPrecision(..)`方法用来指定有效数位的显示位数
            ```javascript
            var a = 42.59;
            a.toPrecision( 1 ); // "4e+1"
            a.toPrecision( 2 ); // "43"
            a.toPrecision( 3 ); // "42.6"
            a.toPrecision( 4 ); // "42.59"
            a.toPrecision( 5 ); // "42.590"
            a.toPrecision( 6 ); // "42.5900"
            ```
        - 上面的方法不仅适用于数字变量，也适用于数字常量。不过对于`.`运算符它是一个有效的数字字符，**会被优先识别为数字常量的一部分**，然后才是对象属性访问运算符
            ```javascript
            // 无效语法：
            42.toFixed( 3 ); // SyntaxError
            // 下面的语法都有效：
            (42).toFixed( 3 ); // "42.000"
            0.42.toFixed( 3 ); // "0.420"
            42..toFixed( 3 ); // "42.000"
            ```
            - `42.tofixed(3)`是无效语法，因为`.`被视为常量`42.`的一部分
            - `42..tofixed(3)`则没有问题，因为第一个`.`被视为number的一部分，第二个`.`是属性访问运算符
            - `42 .toFixed(3); // "42.000"`也是有效的（请注意其中的空格），对数字常量而言，这样的语法很容易引起误会，不建议使用
        - 我们还可以用指数形式来表示较大的数字
            ```javascript
            var onethousand = 1E3; // 即 1 * 10^3
            var onemilliononehundredthousand = 1.1E6; // 即 1.1 * 10^6
            ```
        - 数字常量还可以用其他格式来表示，如二进制、八进制和十六进制
            ```javascript
            0xf3; // 243的十六进制
            0Xf3; // 同上
            0363; // 243的八进制
            ```
            - 从ES6开始，严格模式（strict mode）不再支持0363八进制格式，考虑到将来的兼容性，最好不要再使用
        - ES6支持以下新格式
            ```javascript
            0o363; // 243的八进制
            0O363; // 同上
            0b11110011; // 243的二进制
            0B11110011; // 同上
            ```
    - 二进制浮点数最大的问题是会出现如下情况
        ```javascript
        0.1 + 0.2 === 0.3; // false
        ```
        - 二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断结果为false
    - 在处理带有小数的数字时需要特别注意，通常会设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)
    - 从ES6开始，该值定义在Number.EPSILON中，也可以为ES6之前的版本写polyfill
        ```javascript
        if (!Number.EPSILON) {
            Number.EPSILON = Math.pow(2,-52);
        }
        ```
    - 使用Number.EPSILON来比较两个数字是否相等（在指定的误差范围内）
        ```javascript
        function numbersCloseEnoughToEqual(n1,n2) {
            return Math.abs( n1 - n2 ) < Number.EPSILON;
        }
        var a = 0.1 + 0.2;
        var b = 0.3;
        numbersCloseEnoughToEqual( a, b ); // true
        numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false
        ```
    - 能够呈现的最大浮点数大约是1.798e+308（这是一个相当大的数字），它定义在Number.MAX_VALUE中，最小浮点数定义在Number.MIN_VALUE中，大约是5e-324，它不是负数，但无限接近于0
    - 能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在ES6中被定义为Number.MIN_SAFE_INTEGER
    - 有时JavaScript程序需要处理一些比较大的数字，如数据库中的64位ID等。由于JavaScript的数字类型无法精确呈现64位数值，所以必须将它们保存（转换）为字符串
    - 整数检测：可以使用ES6中的`Number.isInteger(..)`方法
        ```javascript
        Number.isInteger( 42 ); // true
        Number.isInteger( 42.000 ); // true
        Number.isInteger( 42.3 ); // false
        ```
        - 也可以为ES6之前的版本polyfill`Number.isInteger(..)`方法
            ```javascript
            if (!Number.isInteger) {
                Number.isInteger = function(num) {
                    return typeof num == "number" && num % 1 == 0;
                };
            }
            ```
    - 检测一个值是否是安全的整数，可以使用ES6中的`Number.isSafeInteger(..)`方法
        ```javascript
        Number.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true
        Number.isSafeInteger( Math.pow( 2, 53 ) ); // false
        Number.isSafeInteger( Math.pow( 2, 53 ) - 1 ); // true
        ```
        - 可以为ES6之前的版本polyfill`Number.isSafeInteger(..)`方法
            ```javascript
            if (!Number.isSafeInteger) {
                Number.isSafeInteger = function(num) {
                    return Number.isInteger( num ) &&
                        Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
                }; 
            }
            ```
    - 32位有符号整数。虽然整数最大能够达到53位，但是有些数字操作（如数位操作）只适用于32位数字，所以这些操作中数字的安全范围就要小很多，变成从`Math.pow(-2,31)`（-2147483648，约－21亿）到`Math.pow(2,31) - 1`（2147483647，约21 亿）。**因为是有符号的32位，第一位要用于设置正负，所以才是2的31次方；-1的原因是位数是从0开始的，31位都是1等价于32位是1其余位是0的十进制数再减一**
        - `a | 0`可以将变量a中的数值转换为32位有符号整数，因为数位运算符`|`只适用于32位整数。因此与0进行操作即可截取a中的32位数位
        - 某些特殊的值并不是32位安全范围的，如NaN和Infinity，此时会对它们执行虚拟操作（abstract operation）ToInt32，以便转换为符合数位运算符要求的+0值
5.  特殊的数值
    - JavaScript数据类型中有几个特殊的值需要开发人员特别注意和小心使用
    - 不是值的值
        - undefined类型只有一个值，即undefined。null类型也只有一个值，即null。它们的名称既是类型也是值
        - undefined和null常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别
            - null指空值（empty value）或指曾赋过值，但是目前没有值
            - undefined指没有值（missing value）或指从未赋值
            - null是一个特殊关键字，不是标识符，我们**不能将其当作变量来使用和赋值**，而undefined却是一个标识符，可以被当作变量来使用和赋值
    - 在非严格模式下，我们可以为全局标识符undefined赋值
        ```javascript
        function foo() {
            undefined = 2; // 非常糟糕的做法！
        }
        foo();
        function foo() {
            "use strict";
            undefined = 2; // TypeError!
        }
        foo();
        ```
    - 在非严格和严格两种模式下，我们可以声明一个名为undefined的局部变量
        ```javascript
        function foo() {
            "use strict";
            var undefined = 2;
            console.log( undefined ); // 2
        }
        foo();
        ```
    - 但是需要注意，上述对undefined进行赋值和重新声明的做法不可取
    - 通过void运算符即可得到undefined内置标识符的值
        ```javascript
        var a = 42;
        console.log( void a, a ); // undefined 42
        ```
        - 表达式`void ___`没有返回值，因此返回结果是undefined，void并不改变表达式的结果，只是让表达式不返回值
        - 按照惯例我们用`void 0`来获得undefined，`void 0`、`void 1`和undefined之间并没有实质上的区别
        - void运算符在其他地方可以不让表达式返回任何结果（即使其有副作用）
            ```javascript
            function doSomething() {
                // 注： APP.ready 由程序自己定义
                if (!APP.ready) {
                    // 稍后再试
                    return void setTimeout( doSomething,100 );
                }
                var result;
                // 其他
                return result;
            }
            // 现在可以了吗？
            if (doSomething()) {
                // 立即执行下一个任务
            }
            ```
            - 这里`setTimeout(..)`函数返回一个数值，但是为了确保if语句不产生误报（false positive），我们要void掉它返回undefined
            - 另一种更常用的方式是分开`setTimout`与`return`
            ```javascript
            if (!APP.ready) {
                // 稍后再试
                setTimeout( doSomething,100 );
                return;
            }
            ```
    - 特殊的数字
        - 不是数字的数字（如果数学运算的操作数不是数字类型就无法返回一个有效的数字，这种情况下返回值为NaN）
        - NaN意指“不是一个数字”（not a number）。它理解为“无效数值”“失败数值”或者“坏数值”可能更准确些
            ```javascript
            var a = 2 / "foo"; // NaN
            typeof a === "number"; // true
            ```
            - “不是数字的数字”仍然是数字类型
        - NaN是一个“警戒值”，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”
        - 如果要检查变量的值是否为NaN，直接和NaN进行比较不行（不像null或undefined可以直接进行比较）
            ```javascript
            var a = 2 / "foo";
            a == NaN; // false
            a === NaN; // false
            ```
        - NaN是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即`x === x`不成立）的值，而`NaN != NaN`为true
        - 判断NaN的方法，使用`isNaN(..)`
            ```javascript
            var a = 2 / "foo";
            isNaN( a ); // true
            ```
            - `isNaN(..)`是一个内建的全局工具函数
        - NaN方法存在缺陷，它检查参数是否不是NaN，也不是数字
            ```javascript
            var a = 2 / "foo";
            var b = "foo";
            a; // NaN
            b; "foo"
            window.isNaN( a ); // true
            window.isNaN( b ); // true——晕！
            ```
            - 很明显"foo"不是一个数字，但是它也不是NaN
        - ES6中使用工具函数`Number.isNaN(..)`
            ```javascript
            if (!Number.isNaN) {
                Number.isNaN = function(n) {
                    return (
                        typeof n === "number" &&
                        window.isNaN( n )
                    ); 
                };
            }
            var a = 2 / "foo";
            var b = "foo";
            Number.isNaN( a ); // true
            Number.isNaN( b ); // false——好！
            ```
        - 另一个判断NaN的方法是利用NaN的非自反性，是JavaScript中唯一一个不等于自身的值
            ```javascript
            if (!Number.isNaN) {
                Number.isNaN = function(n) {
                    return n !== n;
                };
            }
            ```
        综上我们应该尽量使用`Number.isNaN(..)`这样可靠的方法，无论是系统内置还是polyfill，而不能使用`isNaN(..)`
    - 无穷数
        ```javascript
        var a = 1 / 0; // Infinity
        var b = -1 / 0; // -Infinity
        ```
        - 在JavaScript中，除以0结果为Infinity（即`Number.POSITIVE_INfiNITY`），-Infinity（即`Number.NEGATIVE_INfiNITY`）
        - JavaScript使用有限数字表示法运算结果有可能溢出，此时结果为Infinity或者-Infinity
            ```javascript
            var a = Number.MAX_VALUE; // 1.7976931348623157e+308
            a + a; // Infinity
            a + Math.pow( 2, 970 ); // Infinity
            a + Math.pow( 2, 969 ); // 1.7976931348623157e+308
            ```
            - 规范规定，如果数学运算（如加法）的结果超出处理范围，采取就近取整模式来决定最后的结果
            - 相对于Infinity，`Number.MAX_VALUE + Math.pow(2, 969)`与Number.MAX_VALUE更为接近，因此它被向下取整；而`Number.MAX_VALUE + Math.pow(2, 970)`与Infinity更为接近，所以它被向上取整
            - 计算结果一旦溢出为无穷数（infinity）就无法再得到有穷数
            - 注意：在JavaScript中`Infinity/Infinity`是一个未定义操作，结果为NaN，而不是1或者无穷
            - 有穷正数除以Infinity的结果是0
    - 零值
        - JavaScript有一个常规的0和一个-0，-0除了可以用作常量以外，也可以是某些数学运算的返回值
            ```javascript
            var a = 0 / -3; // -0
            var b = 0 * -3; // -0
            ```
        - 加法和减法运算不会得到负零
        - 负零在开发调试控制台中通常显示为-0
        - 对负零进行字符串化会返回"0"
            ```javascript
            var a = 0 / -3;
            // 至少在某些浏览器的控制台中显示是正确的
            a; // -0
            // 但是规范定义的返回结果是这样！
            a.toString(); // "0"
            a + ""; // "0"
            String( a ); // "0"
            // JSON也如此，很奇怪
            JSON.stringify( a ); // "0"
            ```
        - 如果反过来将其从字符串转换为数字，得到的结果是准确的
            ```javascript
            +"-0"; // -0
            Number( "-0" ); // -0
            JSON.parse( "-0" ); // -0
            ```
        - -0的比较操作
            ```javascript
            var a = 0;
            var b = 0 / -3;
            a == b; // true
            -0 == 0; // true
            a === b; // true
            -0 === 0; // true
            0 > -0; // false 
            a > b; // false
            ```
        - 要区分-0和0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理
            ```javascript
            function isNegZero(n) {
                n = Number( n );
                return (n === 0) && (1 / n === -Infinity);
            }
            isNegZero( -0 ); // true
            isNegZero( 0 / -3 ); // true
            isNegZero( 0 ); // false
            ```
        - 出现-0的原因：有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位（sign）用来代表其他信息（比如移动的方向）。如果一个值为0的变量失去了它的符号位，它的方向信息就会丢失
    - 特殊等式
        - ES6中新加入了一个工具方法`Object.is(..)`来判断两个值是否绝对相等，可以解决0与-1；NaN的判断
            ```javascript
            var a = 2 / "foo";
            var b = -3 * 0;
            Object.is( a, NaN ); // true
            Object.is( b, -0 ); // true
            Object.is( b, 0 ); // false
            ```
        - `Object.is(..)`的polyfill
            ```javascript
            if (!Object.is) {
                Object.is = function(v1, v2) {
                    // 判断是否是-0
                    if (v1 === 0 && v2 === 0) {
                        return 1 / v1 === 1 / v2;
                    }
                    // 判断是否是NaN
                    if (v1 !== v1) {
                        return v2 !== v2;
                    }
                    // 其他情况
                    return v1 === v2;
                };
            }
            ```
        - 能使用`==`和`===`时就尽量不要使用`Object.is(..)`，因为前者效率更高、更为通用。`Object.is(..)`主要用来处理那些特殊的相等比较