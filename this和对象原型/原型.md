<!--
 * @Author: jiaminghui
 * @Date: 2022-12-24 16:55:30
 * @LastEditTime: 2022-12-24 21:41:07
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\this和对象原型\原型.md
 * @Description: 
-->
# 原型的学习
## Prototype
1.  JavaScript中的对象有一个特殊的`[[Prototype]]`内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时`[[Prototype]]`属性都会被赋予一个非空的值
2.  对象的`[[Prototype]]`链接可以为空，但是很少见
3.  `[[Prototype]]`引用的作用
    - 当你试图引用对象的属性时会触发`[[Get]]`操作，比如`myObject.a`，对于默认的`[[Get]]`操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它
        ```javascript
        var myObject = { 
            a:2
        };
        myObject.a; // 2
        ```
    - 但是如果`a`不在myObject中，就需要使用对象的`[[Prototype]]`链了
    - 对于默认的`[[Get]]`操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的`[[Prototype]]`链
        ```javascript
        var anotherObject = { 
            a:2
        };
        // 创建一个关联到 anotherObject 的对象
        var myObject = Object.create( anotherObject ); 
        myObject.a; // 2
        ```
        - `Object.create(..)`的原理，它会创建一个对象并把这个对象的`[[Prototype]]`关联到指定的对象，所以在`myObject.a`时才会访问到原型链`anotherObject`对象上的a属性
        - 如果查找完整条原型链还没有找到对应的属性名时，`[[Get]]`操作的返回值是`undefined`
    - 使用`for..in`遍历对象时原理和查找`[[Prototype]]`链类似，任何可以通过原型链访问到（并且是 enumerable）的属性都会被枚举
    - 使用`in`操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）
        ```javascript
        var anotherObject = { 
            a:2
        };
        // 创建一个关联到 anotherObject 的对象
        var myObject = Object.create( anotherObject );
        for (var k in myObject) { 
            console.log("found: " + k);
        }
        // found: a
        ("a" in myObject); // true
        ```
4.  `[[Prototype]]`链的尽头
    - 所有普通的`[[Prototype]]`链最终都会指向内置的`Object.prototype`
    - 由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把`[[Prototype]]`链的顶端设置为）这个`Object.prototype`对象，所以它包含JavaScript中许多通用的功能
        - `.toString()`
        - `.valueOf()`
        - `.hasOwnProperty(..)`
        - `.isPrototypeOf(..)`
    - 给一个对象设置属性`myObject.foo = "bar";`
        - 如果`myObject`对象中包含名为`foo`的普通数据访问属性，这条赋值语句只会修改已有的属性值
        - 如果`foo`不是直接存在于`myObject`中，`[[Prototype]]`链就会被遍历，类似`[[Get]]`操作。如果原型链上找不到`foo`，`foo`就会被直接添加到`myObject`上
        - 如果`foo`存在于原型链上层，赋值语句`myObject.foo = "bar"`的行为就会有些不同
        - 如果属性名`foo`既出现在`myObject`中也出现在`myObject`的`[[Prototype]]`链上层，那么就会发生屏蔽。`myObject`中包含的`foo`属性会屏蔽原型链上层的所有`foo`属性，因为`myObject.foo`总是会选择原型链中最底层的`foo`属性
5.  如果`foo`不直接存在于`myObject`中而是存在于原型链上层时`myObject.foo = "bar"`会出现的三种情况
    - 如果在`[[Prototype]]`链上层存在名为`foo`的普通数据访问属性**并且没有被标记为只读（writable:true）**，那就会直接在`myObject`中添加一个名为`foo`的新属性，**它是屏蔽属性**
    - 如果在`[[Prototype]]`链上层存在`foo`，但是它被标记为只读（writable:false），那么无法修改已有属性或者在`myObject`上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽
    - 如果在`[[Prototype]]`链上层存在`foo`并且它是一个`setter`，那就一定会调用这个`setter`。`foo`不会被添加到`myObject`，也不会重新定义`foo`这个`setter`
    - 上述三种情况中，只有第一种情况出现了属性屏蔽，如果你希望在第二种和第三种情况下也屏蔽`foo`，那就不能使用`=`操作符来赋值，而是使用 `Object.defineProperty(..)`来向`myObject`添加`foo`
6.  有些情况下会隐式产生屏蔽
    ```javascript
    var anotherObject = { 
        a:2
    };
    var myObject = Object.create( anotherObject ); 
    anotherObject.a; // 2
    myObject.a; // 2 
    anotherObject.hasOwnProperty( "a" ); // true
    // hasOwnProperty只会查找当前对象的属性，并不会查找对象所在原型链上的同名属性
    myObject.hasOwnProperty( "a" ); // false 
    myObject.a++; // 隐式屏蔽！
    anotherObject.a; // 2 
    myObject.a; // 3
    myObject.hasOwnProperty( "a" ); // true
    ```
    - 尽管`myObject.a++`看起来应该（通过委托）查找并增加`anotherObject.a`属性，但是别忘了`++`操作相当于`myObject.a = myObject.a + 1`
    - 因此`++`操作首先会通过`[[Prototype]]`查找属性`a`并从`anotherObject.a`获取当前属性值2，然后给这个值加1，接着用`[[Put]]`将值3赋给`myObject`中新建的屏蔽属性a
    - 如果想让`anotherObject.a`的值增加，唯一的办法是`anotherObject.a++`

## 类
1.  JavaScript和面向类的语言不同，JavaScript中只有对象
2.  JavaScript才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言
3.  JavaScript中的**模仿类**
    - 这种奇怪的“类似类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为`prototype`的公有并且不可枚举的属性，它会指向另一个对象
    ```javascript
    function Foo() { 
        // ...
    }
    Foo.prototype; // { }
    ```
    - 这个对象通常被称为`Foo`的原型，因为我们通过名为`Foo.prototype`的属性引用来访问它
        ```javascript
        function Foo() { 
            // ...
        }
        var a = new Foo();
        Object.getPrototypeOf( a ) === Foo.prototype; // true
        ```
            - 调用`new Foo()`时会创建a，其中的一步就是给a一个内部的`[[Prototype]]`链接，关联到`Foo.prototype`指向的那个对象
4.  在JavaScript中并没有类似的类复制机制（实例化），不能创建一个类的多个实例，只能创建多个对象，它们`[[Prototype]]`关联的是同一个对象`Foo.prototype`
5.  `new Foo()`会生成一个新对象（我们称之为a），这个新对象的内部链接`[[Prototype]]`（`a.prototype`）关联的是`Foo.prototype`对象
    - 我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联
    - `new Foo()`这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用，`new Foo()`只是间接完成了我们的目标：一个关联到其他对象的新对象
6.  原型继承
    - 继承意味着复制操作，JavaScript（默认）并不会复制对象属性
    - JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数
    - **委托**这个术语可以更加准确地描述JavaScript中对象的关联机制
7.  差异继承
    - 我们通过定义了B的一些指定特性，其他没有定义的东西都变成了“洞”
    - 而这些洞（或者说缺少定义的空白处）最终会被委托行为“填满”
8.  “构造函数”
    - 我们看到了关键字new，会让我们认为`Foo`是一个“类”
    - 另外看起来我们执行了类的构造函数方法，`Foo()`的调用方式很像初始化类时类构造函数的调用方式
    - `Foo.prototype`默认有一个公有并且不可枚举的属性`.constructor`，这个属性引用的是对象关联的函数（本例中是`Foo`）。此外，我们可以看到通过“构造函数”调用`new Foo()`创建的对象也有一个`.constructor`属性，指向“创建这个对象的函数”
        ```javascript
        function Foo() { 
            // ...
        }
        Foo.prototype.constructor === Foo; // true
        var a = new Foo(); 
        a.constructor === Foo; // true
        ```
        - 实际上a本身并没有`.constructor`属性，虽然`a.constructor`确实指向`Foo`函数，但是这个属性并不是表示a由`Foo`“构造”
    - `Foo`本身并不是构造函数，在普通的函数调用前面加上`new`关键字之后，就会把这个函数调用变成一个“构造函数调用”，实际上，`new`会劫持所有普通函数并用构造对象的形式来调用它
        ```javascript
        function NothingSpecial() { 
            console.log( "Don't mind me!" );
        }
        var a = new NothingSpecial();
        // "Don't mind me!" 
        a; // {}
        ```
        - `NothingSpecial`只是一个普通的函数，但是使用`new`调用时，它就会构造一个对象并赋值给a
        - 这个调用是一个构造函数调用，但是`NothingSpecial`本身并不是一个构造函数
        - 在JavaScript中对于“构造函数”最准确的解释是，所有带`new`的函数调用。函数不是构造函数，但是当且仅当使用`new`时，函数调用会变成“构造函数调用”
9.  JavaScript中面向类的技巧
    ```javascript
    function Foo(name) { 
        this.name = name;
    }
    Foo.prototype.myName = function() { 
        return this.name;
    }; 
    var a = new Foo( "a" );
    var b = new Foo( "b" ); 
    a.myName(); // "a"
    b.myName(); // "b"
    ```
    - `this.name = name`给每个对象都添加了`.name`属性，有点像类实例封装的数据值
    - `Foo.prototype.myName = ...`给`Foo.prototype`对象添加一个属性（函数）
    - 在创建的过程中，a和b的内部`[[Prototype]]`都会关联到`Foo.prototype`上。当a和b中无法找到`myName`时，它会通过**委托**在`Foo.prototype`上找到
    - 此外`a.constructor === Foo`是因为`.constructor`引用同样被委托给了`Foo.prototype`，而`Foo.prototype.constructor`默认指向`Foo`，这和构造毫无关系
10. `Foo.prototype`的`.constructor`属性只是`Foo`函数在声明时的默认属性。创建了一个新对象并替换了函数默认的`.prototype`对象引用，那么新对象并不会自动获得`.constructor`属性
    ```javascript
    function Foo() { /* .. */ }
    Foo.prototype = { /* .. */ }; // 创建一个新原型对象
    var a1 = new Foo();
    a1.constructor === Foo; // false! 
    a1.constructor === Object; // true!
    ```
    - 上述代码出现`a1.constructor === Object; // true!`的原因是a1并没有`.constructor`属性，所以它会委托`[[Prototype]]`链上的`Foo.prototype`
    - 但是这个对象也没有`.constructor`属性（不过默认的`Foo.prototype`对象有这个属性！）。所以它会继续委托，这次会委托给委托链顶端的`Object.prototype`，这个对象有`.constructor`属性，指向内置的`Object(..)`函数
    - 给`Foo.prototype`添加一个`.constructor`属性修复`.constructor`属性的缺失
        ```javascript
        function Foo() { /* .. */ }
        Foo.prototype = { /* .. */ }; // 创建一个新原型对象
        // 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性
        // 新对象属性起到 Foo.prototype 的作用
        // 关于 defineProperty(..)，参见第 3 章
        Object.defineProperty( Foo.prototype, "constructor" , {
            enumerable: false,  // constructor要求不可枚举
            writable: true,
            configurable: true,
            value: Foo // 让 .constructor 指向 Foo
        } );
        ```
11. 实际上，对象的`.constructor`会默认指向一个函数，这个函数可以通过对象的`.prototype`引用，记住“constructor并不表示被构造”
12. `.constructor`并不是一个**不可变属性**，它只是**不可枚举**，但是它的值是可写的（可以被修改）
    - 此外，你可以给任意`[[Prototype]]`链中的任意对象添加一个名为`constructor`的属性或者对其进行修改，你可以任意对其赋值
    - `a1.constructor`是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用

## 原型继承
1. `Bar.prototype`到`Foo.prototype`的委托关系
    ```javascript
    function Foo(name) { 
        this.name = name;
    }
    Foo.prototype.myName = function() { 
        return this.name;
    };
    function Bar(name,label) { 
        Foo.call( this, name ); 
        this.label = label;
    }
    // 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype
    Bar.prototype = Object.create( Foo.prototype );
    // 注意！现在没有 Bar.prototype.constructor 了
    // 如果你需要这个属性的话可能需要手动修复一下它
    Bar.prototype.myLabel = function() { 
        return this.label;
    };
    var a = new Bar( "a", "obj a" );
    a.myName(); // "a" 
    a.myLabel(); // "obj a"
    ```
    - 代码的核心部分就是语句`Bar.prototype = Object.create( Foo.prototype )`
    - 声明`function Bar() { .. }`时Bar会有一个`.prototype`关联到默认的对象，但是这个对象并不是我们想要的`Foo.prototype`
    - `Object.create(..)`创建一个新的`Bar.prototype`对象并把它关联到`Foo.prototype`
    - 但是下述两种方式并不会完成我们希望的对象关联
        ```javascript
        // 和你想要的机制不一样！
        Bar.prototype = Foo.prototype;
        // 基本上满足你的需求，但是可能会产生一些副作用 :( 
        Bar.prototype = new Foo();
        ```
        - 方式一：`Bar.prototype = Foo.prototype`它只是让`Bar.prototype`直接引用`Foo.prototype`对象。当你执行类似`Bar.prototype.myLabel = ...`的赋值语句时会直接修改`Foo.prototype`对象本身
        - 方式二：`Bar.prototype = new Foo()`的确会创建一个关联到`Bar.prototype`的新对象，但是它使用了`Foo(..)`的“构造函数调用”，如果函数`Foo`有一些副作用（比如写日志、修改状态、注册到其他对象、给`this`添加数据属性，等等）的话，就会影响到`Bar()`的“后代”
        - 因此，要创建一个合适的关联对象，我们必须使用`Object.create(..)`，这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象
    - ES6之前我们只能通过设置`.__proto__`属性来实现修改对象的`[[Prototype]]`关联但是这个方法并不是标准并且无法兼容所有浏览器
    - ES6添加了辅助函数`Object.setPrototypeOf(..)`，可以用标准并且可靠的方法来修改关联
        ```javascript
        // ES6 之前需要抛弃默认的 Bar.prototype
        Bar.ptototype = Object.create( Foo.prototype );
        // ES6 开始可以直接修改现有的 Bar.prototype
        Object.setPrototypeOf( Bar.prototype, Foo.prototype );
        ```
        - 如果忽略掉`Object.create(..)`方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比ES6及其之后的方法更短而且可读性更高
