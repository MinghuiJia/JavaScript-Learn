<!--
 * @Author: jiaminghui
 * @Date: 2022-12-12 16:24:10
 * @LastEditTime: 2022-12-12 23:26:33
 * @LastEditors: jiaminghui
 * @FilePath: \JavaScript_Learn\this和对象原型\对象.md
 * @Description: 
-->
# 对象的学习

## 语法
1.  对象的定义：声明形式和构造形式
    - 声明形式
        ```javascript
        var myObj = {
            key: value
            // ...
        };
        ```
    - 构造形式
        ```javascript
        var myObj = new Object();
        myObj.key = value;  
        ```
    - 声明形式与构造形式创建的对象是一样的，区别在于声明形式可以添加多个键值对，而构造形式只能逐个添加属性
## 类型
1.  javascript中有**六种主要类型**
    - string
    - number
    - boolean
    - null
    - undefined
    - object
2.  简单的基本类型是除了`object`之外的五个类型
3.  `null`在执行`typeof null`时会返回`object`字符串，但实际上`null`本身是基本类型
    - 这是因为`typeof`是判断对象在底层的二进制形式，如果二进制前三位都是0会被判断为`object`类型。`null`的二进制全为0
4.  “JavaScript中万物皆是对象”的表达有误，只是存在很多对象的子类型——**复杂基本类型**
    - 函数是对象的子类型，是可调用的对象（可以像操作其他对象一样操作函数——当作另一个函数的参数）
    - 数组也是对象的子类型，具备一些额外的行为
5.  内置对象：是JavaScript中的一些对象子类型，从名称上看与基础类型一样，但实际上它们之间关系复杂
    - String
    - Number
    - Boolean
    - Object
    - Function
    - Array
    - Date
    - RegExp
    - Error
    这些内置对象的形式看上去像类(class)，但实际上是**内置函数**，通过new关键词调用构造函数，从而构造一个对应子类的新对象
        ```javascript
        var strPrimitive = "I am a string"; 
        typeof strPrimitive; // "string" 
        strPrimitive instanceof String; // false
        var strObject = new String( "I am a string" ); 
        typeof strObject; // "object"
        strObject instanceof String; // true
        // 检查 sub-type 对象
        Object.prototype.toString.call( strObject ); // [object String]
        ```
    - 从代码中可以看到，`strObject`是由`String`构造函数创建的一个对象
    - "I am a string"本质上是一个字面量（不可变的值）。如果想对这个字面量执行一些操作：获取长度、访问某个字符等，需要将字面量转换为`String`对象
    - 在语言中，实际上它会自动把字符串字面量转换成一个`String`对象
        ```javascript
        var strPrimitive = "I am a string";
        console.log( strPrimitive.length ); // 13
        console.log( strPrimitive.charAt( 3 ) ); // "m"
        ```
    - 数值字面量（number）与布尔字面量（boolean）也会被自动转成`Number`对象与`Boolean`对象
    - `null`与`undefined`没有对应的构造函数，只有文字形式；而`Date`只有构造函数，没有文字形式
    - 对于`Object`、`Array`、`Function`和`RegExp`（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量
    - 由于对象创建使用构造形式可以提供额外的选项，所以在那些需要额外选项的地方使用构造形式，其他地方使用更简单的文字形式
    - `Error`对象很少在代码中显式创建，一般是在抛出异常时被自动创建
## 内容
1.  对象的内容我们称之为属性，它并不存储在对象容器内部。存储在对象容器内部的是属性的名称（即引用），指向这些值真正存储的位置
    ```javascript
    var myObject = {
        a: 2
    };
    myObject.a; // 2
    myObject["a"]; // 2
    ```
    - `myObject.a`称为属性访问；`myObject["a"]`称为键访问
    - 属性访问需要满足标识符的命名规范，而键访问可以接受任意字符串作为属性名，并且键访问可以在程序中构造字符串
    - 属性名永远都是字符串，使用`string`以外的其他值作为属性名时，都会首先被转换为字符串
        ```javascript
        var myObject = { };
        myObject[true] = "foo"; 
        myObject[3] = "bar"; 
        myObject[myObject] = "baz";
        myObject["true"]; // "foo"
        myObject["3"]; // "bar"
        myObject["[object Object]"]; // "baz"
        ```
2.  在通过**文字声明形式**来定义对象时，把表达式当作属性名是不行的，需要使用ES6新加的**可计算属性名**（使用[]包裹表达式当作属性名）来完成功能
    ```javascript
    var prefix = "foo";
    var myObject = {
        [prefix + "bar"]:"hello", 
        [prefix + "baz"]: "world"
    };
    myObject["foobar"]; // hello
    myObject["foobaz"]; // world
    ```
    - 可计算属性名最常用的常见是ES6的**符号（Symbol）**，它是一个包含不透明且无法预测的值（不同的引擎对应的值不同），使用方法通常是使用符号的名称`Symbol.Something`
        ```javascript
        var myObject = {
            [Symbol.Something]: "hello world"
        }
        ```
3.  由于在JavaScript中，函数永远不会属于一个对象（函数中的this是根据调用位置动态绑定的），所以把对象内部的函数称为方法有些不妥
    - 访问对象的属性无论返回值是什么类型，都是对象的属性访问。如果属性访问返回的函数，它与其他函数没有任何区别（除了可能存在this的隐式绑定）
    - 即使以文字形式在对象内声明一个函数表达式，这个函数也不属于这个对象，它们只是对于相同函数对象的多个引用
        ```javascript
        var myObject = { 
            foo: function() {
                console.log( "foo" );
            }
        };
        ```
4.  数组也支持[]访问形式，值存储的位置是整数（索引）。数组不限制值的类型
    ```javascript
    var myArray = [ "foo", 42, "bar" ]; 
    myArray.length; // 3
    myArray[0]; // "foo"
    myArray[2]; // "bar"
    ```
    - **数组也是对象**，可以给数组添加属性
        ```javascript
        var myArray = [ "foo", 42, "bar" ]; 
        myArray.baz = "baz"; 
        myArray.length; // 3
        myArray.baz; // "baz"
        ```
    - 虽然给数组可以添加属性，但是并不会改变数组的长度`length`
    - 虽然看上去数组也可以添加很多键值对，但是数组和对象分别针对用途进行了优化，最好还是用对象存储键值对，数组存储数值下标值对
    - 注意：如果对数组添加属性看起来像数字，它会将其转换成数字然后修改数组对应下标的内容
        ```javascript
        var myArray = [ "foo", 42, "bar" ]; 
        myArray["3"] = "baz"; 
        myArray.length; // 4
        myArray[3]; // "baz"
        ```
5.  复制对象：浅拷贝与深拷贝
    ```javascript
    function anotherFunction() { /*..*/ }
    var anotherObject = { 
        c: true
    };
    var anotherArray = [];
    var myObject = { 
        a: 2,
        b: anotherObject, // 引用，不是复本！
        c: anotherArray, // 另一个引用！
        d: anotherFunction
    };
    anotherArray.push( anotherObject, myObject );
    ```
    - 对于浅拷贝来说，复制出的新对象中`a`属性的值会复制旧对象中`a`的值（2），但是新对象中的`b`、`c`、`d`只是三个引用，它们与旧对象中引用的对象是一样的
        - ES6中定义了`Object.assign(..)实现浅拷贝，它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到（=操作赋值）目标对象`
            ```javascript
            var newObj = Object.assign( {}, myObject );
            newObj.a; // 2
            newObj.b === anotherObject; // true 
            newObj.c === anotherArray; // true 
            newObj.d === anotherFunction; // true
            ```
        - `Object.assign(..)使用=操作符赋值，所以源对象属性的一些特性（writable）不会被复制到目标对象`
    - 对于深拷贝来说，除了复制`myObject`外，还会复制`anotherObject`与`anotherArray`。但上述代码在复制`anotherArray`时由于又引用了`anotherObject`与`myObject`，会造成死循环
    - 此外，复制函数的方法有人会通过`toString()`来序列化一个函数的源代码
        - 因此，深拷贝在许多JavaScript框架中都没有一个标准的做法
        - 对于JSON安全的（可序列化为JSON字符串，并可以再解析出相同对象）对象可以采用字符串序列化与解析的方式深拷贝对象
            ```javascript
            var newObj = JSON.parse( JSON.stringify( someObj ) );
            ```
6.  属性描述符
    从ES5开始，对象的所有属性具备了属性描述符（判断属性是否只读等）
    ```javascript
    var myObject = { 
        a:2
    };
    Object.getOwnPropertyDescriptor( myObject, "a" ); 
    // {
    // value: 2,
    // writable: true,
    // enumerable: true,
    // configurable: true
    // }
    ```
    - `myObject`对象中的属性`a`对应的属性描述符，不仅包括属性值2，还包括另外三个特性：writable（可写）、enumerable（可枚举）和configurable（可配置）
    - 可以使用`Object.defineProperty(..)`来添加新的属性或修改已有属性（如果是configurable），并对特性进行设置
        ```javascript
        var myObject = {};
        Object.defineProperty( myObject, "a", {
            value: 2,
            writable: true, 
            configurable: true, 
            enumerable: true
        } ); 
        myObject.a; // 2
        ```
        - 一般情况下不会这种方式添加属性，除非想要修改属性描述符

    - 属性描述符的含义
        - writable：决定是否可以修改属性的值
            在严格模式下还会报错，无法修改一个不可写的属性
            ```javascript
            var myObject = {};
            Object.defineProperty( myObject, "a", {
                value: 2,
                writable: false, // 不可写！
                configurable: true,
                enumerable: true
            } );
            myObject.a = 3;
            myObject.a; // 2

            /// 严格模式下
            "use strict";
            var myObject = {};
            Object.defineProperty( myObject, "a", {
                value: 2,
                writable: false, // 不可写！
                configurable: true,
                enumerable: true
            } );
            myObject.a = 3; // TypeError
            ```
        - configurable：只要属性是可配置的，就可以使用`Object.defineProperty`来修改属性描述符
            ```javascript
            var myObject = { 
                a:2
            };
            myObject.a = 3;
            myObject.a; // 3
            Object.defineProperty( myObject, "a", {
                value: 4,
                writable: true,
                configurable: false, // 不可配置！
                enumerable: true
            } );
            myObject.a; // 4 
            myObject.a = 5; 
            myObject.a; // 5
            Object.defineProperty( myObject, "a", {
                value: 6,
                writable: true, 
                configurable: true, 
                enumerable: true
            } ); // TypeError
            ```
            1.把`configurable`设置为false是单向操作，无法撤销
            2.注意：**即使configurable:false，还是可以把writable的状态由true改为false，但是无法由false改为true**
            3.除了无法修改，configurable:false还会禁止删除这个属性
            ```javascript
            var myObject = { 
                a:2
            };
            myObject.a; // 2
            delete myObject.a; 
            myObject.a; // undefined
            Object.defineProperty( myObject, "a", {
                value: 2,
                writable: true, 
                configurable: false, 
                enumerable: true
            } );
            myObject.a; // 2 
            delete myObject.a; 
            myObject.a; // 2
            ```
            注意：当对象的属性是函数或对象时，删除对象的属性并且这个属性是对象的最后一个引用者，`delete`之后未被引用的函数或对象会被垃圾回收
        - enumerable：控制的是属性是否会出现在对象的属性枚举中（for..in 循环）。如果设置成false，这个属性就不会出现在枚举中，这样一个特殊的属性就不会出现在枚举中
7.  不变性
    当我们希望对象或者内部的属性不可改变，ES5中可以通过很多方法实现，但是这些方法都是**浅不变**，只会影响**目标对象和它的直接属性**。对于那些**引用属性**（数组、对象、函数等）不受影响，**仍然是可变的**
    ```javascript
    myImmutableObject.foo; // [1,2,3] 
    myImmutableObject.foo.push( 4 ); 
    myImmutableObject.foo; // [1,2,3,4]
    ```
    上述代码中假设`myImmutableObject`已经是不可变的，但是为了保护内部的`foo`，还需要使用下面的方法让`foo`也不可变
    1.  对象常量：结合`writable:false和configurable:false`就可以创建一个真正的常量属性（不可修改、重新定义或删除）
        ```javascript
        var myObject = {};
        Object.defineProperty( myObject, "FAVORITE_NUMBER", {
            value: 42,
            writable: false,
            configurable: false
        } );
        ```
    2.  禁止扩展：禁止对象添加新属性并且保留已有属性（`Object.preventExtensions(..)`）
        ```javascript
        var myObject = { 
            a:2
        };
        Object.preventExtensions( myObject );
        myObject.b = 3; 
        myObject.b; // undefined
        ```
        - 在在非严格模式下，创建属性b会静默失败。在严格模式下，将会抛出TypeError错误
    3.  密封
        - 密封`Object.seal(..)`实际上会在现有对象上调用`Object.preventExtensions(..)`，并把所有现有属性标记为`configurable:false`
        - 密封之后不仅不能添加新属性，也不能重新配置或删除任何现有属性（但是可以修改现有属性）
    4.  冻结
        - 冻结`Object.freeze(..)`实际上会在一个现有对象上调用`Object.seal(..)`，并把所有“数据访问”属性标记为`writable:false`，这样就无法修改它们的值
    - 这些方法是可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（引用属性不受影响）
    - 深度冻结的方式：首先在这个对象上调用`Object.freeze(..)`，然后遍历它引用的所有对象并在这些对象上调用`Object.freeze(..)`
    - 深度冻结可能会无意东街道其他共享对象
